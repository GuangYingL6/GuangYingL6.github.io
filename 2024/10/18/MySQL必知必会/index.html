<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="计算机 编程 网络 操作系统">
    
    <meta name="author" content="GuangYing">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="http://guangying.com/2024/10/18/mysql必知必会/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
        <meta name="description" content="阅读MySQL必知必会做的笔记，看完忘了就不好了(">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL必知必会笔记">
<meta property="og:url" content="http://guangying.com/2024/10/18/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/index.html">
<meta property="og:site_name" content="记事本">
<meta property="og:description" content="阅读MySQL必知必会做的笔记，看完忘了就不好了(">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-10-18T07:52:53.000Z">
<meta property="article:modified_time" content="2024-11-05T13:30:08.260Z">
<meta property="article:author" content="GuangYing">
<meta property="article:tag" content="笔记">
<meta property="article:tag" content="MySQL">
<meta property="article:tag" content="数据库">
<meta name="twitter:card" content="summary">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/img/ico.jpg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/img/ico.jpg">
    <meta name="theme-color" content="#429ce3">
    <link rel="shortcut icon" href="/img/ico.jpg">
    <!--- Page Info-->
    
    <title>
        
            MySQL必知必会笔记 -
        
        芝士博客
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/assets/build/styles.css">

    

    
<link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css">

    
<link rel="stylesheet" href="/fonts/Geist/geist.css">

    <!--- Font Part-->
    
    
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"guangying.com","root":"/","language":"zh-CN"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"tokyo-night-dark"},"font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":6,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#429ce3","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":false,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"open_graph":true,"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"去码头搞点芝士","subtitle":{"text":["饿了","我补药吃拼好饭啊啊啊啊啊"],"hitokoto":{"enable":false,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null,"fa-brands fa-github":"https://github.com/GuangYingL6","fa-solid fa-envelope":"mailto:692466332@qq.com"},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":false,"version":"9.3.0"}},"version":"2.7.1","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"GitHub":{"path":"https://github.com/GuangYingL6","icon":"fa-brands fa-github"},"Google":{"path":"https://www.google.com/","icon":"fa-brands fa-google"},"友链":{"path":"/links/","icon":"fa-solid fa-link"}},"search":{"enable":false,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":"我宣布个事啊","show_on_mobile":true,"links":{"档案":{"path":"/archives","icon":"fa-regular fa-archive"},"标签":{"path":"/tags","icon":"fa-regular fa-tags"},"分类":{"path":"/categories","icon":"fa-regular fa-folder"}}},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2024/10/17 11:45:14"};
    window.lang_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
<!--        <span class="swup-progress-icon">-->
<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
<!--        </span>-->
    
</div>



<main class="page-container" id="swup">

    

    <div class="main-content-container">


        <div class="main-content-header">
            <header class="navbar-container px-6 md:px-12">

    <div class="navbar-content ">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="/img/ico.jpg">
                </a>
            
            <a class="logo-title" href="/">
                
                芝士博客
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    首页
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   target="_blank" rel="noopener" href="https://github.com/GuangYingL6"
                                        >
                                    <i class="fa-brands fa-github fa-fw"></i>
                                    GITHUB
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   target="_blank" rel="noopener" href="https://www.google.com/"
                                        >
                                    <i class="fa-brands fa-google fa-fw"></i>
                                    GOOGLE
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/links/"
                                        >
                                    <i class="fa-solid fa-link fa-fw"></i>
                                    友链
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-screen w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                首页
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           target="_blank" rel="noopener" href="https://github.com/GuangYingL6"
                        >
                            <span>
                                GITHUB
                            </span>
                            
                                <i class="fa-brands fa-github fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           target="_blank" rel="noopener" href="https://www.google.com/"
                        >
                            <span>
                                GOOGLE
                            </span>
                            
                                <i class="fa-brands fa-google fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/links/"
                        >
                            <span>
                                友链
                            </span>
                            
                                <i class="fa-solid fa-link fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            

            
            
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/archives"
                        >
                            <span>档案</span>
                            <i class="fa-regular fa-archive fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/tags"
                        >
                            <span>标签</span>
                            <i class="fa-regular fa-tags fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/categories"
                        >
                            <span>分类</span>
                            <i class="fa-regular fa-folder fa-sm fa-fw"></i>
                        </a>
                    </li>
                
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">7</div>
        <div class="label text-third-text-color text-sm">标签</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">3</div>
        <div class="label text-third-text-color text-sm">分类</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">7</div>
        <div class="label text-third-text-color text-sm">文章</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="main-content-body">

            

            <div class="main-content">

                
                    <div class="post-page-container flex relative justify-between box-border w-full h-full">
    <div class="article-content-container">

        <div class="article-title relative w-full">
            
                
                
                <img src="/img/Snipaste_2024-10-20_22-09-17.jpg" alt="MySQL必知必会笔记" class="w-full h-60 sm:h-72 md:h-80 object-cover sm:rounded-t-large dark:brightness-75"/>
                
                <div class="w-full flex items-center absolute bottom-0 justify-start">
                    <h1 class="article-title-cover text-center mx-6 my-6 text-second-text-color bg-background-color-transparent px-4 py-3 text-3xl sm:text-4xl md:text-5xl font-semibold backdrop-blur-lg rounded-xl border border-border-color ">MySQL必知必会笔记</h1>
                </div>
            
            </div>

        
            <div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
                <div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
                    <img src="/img/avat.jpg">
                </div>
                <div class="info flex flex-col justify-between">
                    <div class="author flex items-center">
                        <span class="name text-default-text-color text-lg font-semibold">GuangYing</span>
                        
                            <span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv1</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2024-10-18 15:52:53</span>
        <span class="mobile">2024-10-18 15:52:53</span>
        <span class="hover-info">创建</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2024-11-05 21:30:08</span>
            <span class="mobile">2024-11-05 21:30:08</span>
            <span class="hover-info">更新</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/MySQL/">MySQL</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        


        <div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
            <h1 id="使用MySQL"><a href="#使用MySQL" class="headerlink" title="使用MySQL"></a>使用MySQL</h1><h2 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h2><p>输入：<code>USE crashcourse;</code></p>
<p>​	选择crashcourse数据库</p>
<p>必须先使用USE打开数据库，才能读取其中的数据</p>
<h2 id="了解数据库和表"><a href="#了解数据库和表" class="headerlink" title="了解数据库和表"></a>了解数据库和表</h2><p>输入：<code>SHOW DATABASES;</code></p>
<p>​	返回可用数据库的一个列表</p>
<p>输入：<code>SHOW TABLES;</code></p>
<p>​	返回当前选择的数据库内可用表的列表</p>
<p>输入：<code>SHWO COLUMNS FROM customers;</code></p>
<p>​	<code>SHOW COLUMNS</code>返回表customers的字段信息</p>
<p><strong>自动增量</strong>：</p>
<p>​	某些表列需要唯一值，MySQL可自动为每个行分配下一个可用编号，无需手动分配唯一值</p>
<p><code>DESCRIBE</code>语句</p>
<p>​	MySQL支持用<code>DESCRIBE</code>作为<code>SHOW COLUMNS FROM</code>的一种快捷方式</p>
<p>所支持的其他<code>SHOW</code>语句还有：</p>
<p>​	+ <code>SHOW STATUS</code>：用于显示广泛的服务器状态信息</p>
<p>​	+ <code>SHOW CREATE DATABASE</code>和<code>SHOW CREATE TABLE</code>：显式创建特定数据库或表的MySQL语句</p>
<p>​	+ <code>SHOW GRANTS</code>：用来显示授予用户(所有用户或特定用户)的安全权限</p>
<p>​	+ <code>SHOW ERRORS</code>和<code>SHOW WARNINGS</code>：用来显示服务器错误或警告消息</p>
<p><code>HELP SHOW;</code>：显示允许的SHOW语句</p>
<hr>
<h1 id="检索数据"><a href="#检索数据" class="headerlink" title="检索数据"></a>检索数据</h1><h2 id="SELECT语句"><a href="#SELECT语句" class="headerlink" title="SELECT语句"></a>SELECT语句</h2><p>必须至少给出的两条信息：想选择什么 + 从什么地方选择</p>
<h2 id="检索单个列"><a href="#检索单个列" class="headerlink" title="检索单个列"></a>检索单个列</h2><p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name</span><br><span class="line">FROM products;</span><br></pre></td></tr></table></figure></div>

<p>​	从products表中检索名为prod_name的列</p>
<p>​	FROM关键字指出从其中检索数据的表名</p>
<p><strong>未排序数据</strong>：若为明确排序查询结果，则返回的数据没有特殊一样</p>
<p><strong>结束SQL语句</strong>：多条SQL语句必须以分号(;)分隔</p>
<p>​	MySQL不需要在单条SQL语句后加分号，但<strong>特定DBMS</strong>和<strong>mysql命令行</strong>必须加上分号</p>
<p><strong>SQL语句和大小写</strong>：SQL语句不区分大小写</p>
<p>​	习惯对所有SQL关键字使用大写，而对所有列和表名使用小写</p>
<p>MySQL4.1及之前的版本中数据库名、列名、表名等标识符是区分大小写的</p>
<p><strong>使用空格</strong>：处理SQL语句时，其中所有空格都被忽略</p>
<h2 id="检索多个列"><a href="#检索多个列" class="headerlink" title="检索多个列"></a>检索多个列</h2><p>必须在SELECT关键字后给出多个列名，列名之间以逗号分隔</p>
<p><strong>当心逗号</strong>：选择多个列时，列间需要加逗号，但最后一个列名后不加</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_id, prod_name, prod_price</span><br><span class="line">FROM products;</span><br></pre></td></tr></table></figure></div>

<p>​	从表总选择数据，指定了3个列名</p>
<p><strong>数据表示</strong>：SQL语句一般返回原始的无格式的数据</p>
<p>​	一般很少使用实际检索出的原始数据(没有应用程序提供的格式)</p>
<h2 id="检索所有列"><a href="#检索所有列" class="headerlink" title="检索所有列"></a>检索所有列</h2><p>通过在实际列名的位置使用星号(*)通配符</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM products;</span><br></pre></td></tr></table></figure></div>

<p>​	此时列的顺序一般是列在表定义中出现的顺序</p>
<p>​	有时不是这样，表的模式的变化(添加或删除等)可能导致顺序的变化</p>
<p><strong>使用通配符</strong>：一般，除非确实需要表中每个列，否则最好别使用*通配符</p>
<p>​	检索不需要的列通常会降低检索和应用程序的性能</p>
<p><strong>检索未知列</strong>：使用通配符的一大优点，能检索出名字未知的列</p>
<h2 id="检索不同的行"><a href="#检索不同的行" class="headerlink" title="检索不同的行"></a>检索不同的行</h2><p>使用DISTINCT关键字，此关键字指示MySQL只返回不同的值</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT vend_id</span><br><span class="line">FROM products;</span><br></pre></td></tr></table></figure></div>

<p>​	如果使用DISTINCT关键字，必须直接放在列名的最前面</p>
<p><strong>不能部分使用DISTINCT</strong>：DISTINCT关键字应用于所有列而不仅是前置它的列</p>
<h2 id="限制结果"><a href="#限制结果" class="headerlink" title="限制结果"></a>限制结果</h2><p>SELECT语句返回所有匹配的行</p>
<p>可使用LIMIT子句，如：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name</span><br><span class="line">FROM products</span><br><span class="line">LIMIT 5;</span><br></pre></td></tr></table></figure></div>

<p>​	使用SELECT语句检索单个列</p>
<p>​	<code>LIMIT 5</code>指示MySQL返回不多于5行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name</span><br><span class="line">FROM products</span><br><span class="line">LIMIT 5,5;</span><br></pre></td></tr></table></figure></div>

<p>​	<code>LIMIT 5,5</code>指示MySQL返回从行5开始的5行</p>
<p>​	第一个数为开始位置，第二个数为要检索的行数</p>
<p>带一个值的LIMIT总是从第一行开始，给出的数为返回的行数</p>
<p>带两个值的LIMIT可以指定从行号为第一个值的位置开始</p>
<p><strong>行0</strong>：检索出来的第一行为0不是行1</p>
<p>​	因此<code>LIMIT 1, 1</code>将检索出第二行而不是第一行</p>
<p><strong>在行数不够时</strong>：MySQL将只返回它能返回的那么多行</p>
<p><strong>MySQL 5的LIMIT语法</strong>：</p>
<p>​	支持另一种替代语法：<code>LIMIT 4 OFFSET 3</code></p>
<p>​	表示：从行3开始取4行，就像<code>LIMIT 3, 4</code>一样</p>
<h2 id="使用完全限定的表名"><a href="#使用完全限定的表名" class="headerlink" title="使用完全限定的表名"></a>使用完全限定的表名</h2><p>即同时使用表名和列字</p>
<p>例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT  products.prod_name</span><br><span class="line">FROM crashcourse.products;</span><br></pre></td></tr></table></figure></div>

<p>​	表名和列字都可以是完全限定的(假定products表确实位于crashcourse数据库中)</p>
<p>有些情况需要完全限定名，留着备用</p>
<hr>
<h1 id="排序检索数据"><a href="#排序检索数据" class="headerlink" title="排序检索数据"></a>排序检索数据</h1><p>使用SELECT语句的ORDER BY子句，根据需要排序检索出数据</p>
<h2 id="排序数据"><a href="#排序数据" class="headerlink" title="排序数据"></a>排序数据</h2><p>若不排序数据，顺序会收到MySQL重用回收存储空间的影响</p>
<p>因此，若不规定排序顺序，则不应该假定检索出的数据顺序有意义</p>
<p><strong>子句</strong>：SQL语句由子句构成，有些子句必须，有些可选</p>
<p>​	一个子句通常由一个关键子和所提供的数据组成</p>
<p>可使用<code>ORDER BY</code>子句</p>
<p>​	取一个或多个列的名字，据此对输出排序</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name</span><br><span class="line">FROM products</span><br><span class="line">ORDER BY prod_name;</span><br></pre></td></tr></table></figure></div>

<p>​	<code>ORDER BY</code>子句对prod_name列以字母顺序排序</p>
<p><strong>通过非选择列进行排序</strong>：</p>
<p>​	通常<code>ORDER BY</code>子句中使用的列将会是被显示的列</p>
<p>​	但用非检索的列排序数据是完全合法的</p>
<h2 id="按多个列排序"><a href="#按多个列排序" class="headerlink" title="按多个列排序"></a>按多个列排序</h2><p>只要指定列名，列名间用逗号分开即可(跟选择多个列时似的)</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_id, prod_price, prod_name</span><br><span class="line">FROM products</span><br><span class="line">ORDER BY prod_price, prod_name;</span><br></pre></td></tr></table></figure></div>

<p>​	检索两个列，排序两个列</p>
<p>​	尽在多个行具有相同的prod_price值时，才按照prod_name进行排序(左侧先排)</p>
<h2 id="指定排序方向"><a href="#指定排序方向" class="headerlink" title="指定排序方向"></a>指定排序方向</h2><p>升序排序(从A到Z)是默认排序顺序</p>
<p>若进行降序排序：必须指定DESC关键字</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_id, prod_price, prod_name</span><br><span class="line">FROM products</span><br><span class="line">ORDER BY prod_price DESC, prod_name;</span><br></pre></td></tr></table></figure></div>

<p>​	按prod_price降序排序，再对prod_name升序排序</p>
<p>DESC关键字只应用到直接位于其前面的列名</p>
<p><strong>在多个列上降序排序</strong>：必须对每个列指定DESC关键字</p>
<p>ASC关键字与DESC相反，按升序排序(但是没啥用，升序是默认的)</p>
<p><strong>区分大小写和排序顺序</strong>：在字典排序顺序中，A被视为与a相同，这是MySQL的默认行为</p>
<p>​	<code>ORDER BY</code>子句无法改变这种排序顺序</p>
<p>使用<code>ORDER BY</code>和<code>LIMIT</code>组合，能找出一个列中最高或最低的值</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_price</span><br><span class="line">FROM products</span><br><span class="line">ORDER BY prod_price DESC</span><br><span class="line">LIMIT 1;</span><br></pre></td></tr></table></figure></div>

<p>​	<code>prod_peice DESC</code>保证按照降序排序</p>
<p>​	<code>LIMIT 1</code>则只返回一行</p>
<p><strong><code>ORDER BY</code>子句的位置</strong>：<code>ORDER BY</code>子句应位于<code>FROM</code>子句后</p>
<p>​	若使用<code>LIMIT</code>，则其必须位于<code>ORDER BY</code>之后</p>
<p>​	使用子句的次序不对将产生错误消息</p>
<hr>
<h1 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h1><p>使用SELECT语句的WHERE子句指定搜索条件</p>
<h2 id="使用WHERE子句"><a href="#使用WHERE子句" class="headerlink" title="使用WHERE子句"></a>使用WHERE子句</h2><p>只检索所需数据需要指定<strong>搜索条件</strong>(<strong>过滤条件</strong>)</p>
<p>在SELECT语句中，数据根据WHERE子句中指定的搜索条件进行过滤</p>
<p>​	WHERE子句在表名(FROM子句)之后给出</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_price = 2.50;</span><br></pre></td></tr></table></figure></div>

<p>​	从products表中检索两个列，只返回prod_price值为2.50的行</p>
<p><strong>SQL过滤与应用过滤</strong>：数据也可以在应用层过滤</p>
<p>​	SQL的SELECT语句为客户机应用检索出超过实际所需的数据，然后客户机代码对返回数据进行循环，以取出需要的行</p>
<p>​	让客户机应用处理数据库的工作将会极大的影响应用的性能，并且应用完全不具备可伸缩性，还会导致网络带宽的浪费</p>
<p><strong>WHERE子句的位置</strong>：</p>
<p>​	让<code>ORDER BY</code>位于<code>WHERE</code>之后，否则将产生错误</p>
<h2 id="WHERE子句操作符"><a href="#WHERE子句操作符" class="headerlink" title="WHERE子句操作符"></a>WHERE子句操作符</h2><p>MySQL支持表中列出的所有条件操作符</p>
<table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&#x3D;</td>
<td align="left">等于</td>
</tr>
<tr>
<td align="center">&lt;&gt;</td>
<td align="left">不等于</td>
</tr>
<tr>
<td align="center">!&#x3D;</td>
<td align="left">不等于</td>
</tr>
<tr>
<td align="center">&lt;</td>
<td align="left">小于</td>
</tr>
<tr>
<td align="center">&lt;&#x3D;</td>
<td align="left">小于等于</td>
</tr>
<tr>
<td align="center">&gt;</td>
<td align="left">大于</td>
</tr>
<tr>
<td align="center">&gt;&#x3D;</td>
<td align="left">大于等于</td>
</tr>
<tr>
<td align="center">BETWEEN</td>
<td align="left">在指定的两个值之间</td>
</tr>
</tbody></table>
<h3 id="检查单个值"><a href="#检查单个值" class="headerlink" title="检查单个值"></a>检查单个值</h3><p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_name = &#x27;fuses&#x27;;</span><br></pre></td></tr></table></figure></div>

<p>​	MySQL在执行匹配时默认不区分大小写</p>
<h3 id="不匹配检查"><a href="#不匹配检查" class="headerlink" title="不匹配检查"></a>不匹配检查</h3><p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_id, prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_id &lt;&gt; 1003;</span><br></pre></td></tr></table></figure></div>



<p><strong>何时使用引号</strong>：单引号用来限定字符串，与数值列比较的值不用引号</p>
<h3 id="范围值检查"><a href="#范围值检查" class="headerlink" title="范围值检查"></a>范围值检查</h3><p>可使用<code>BETWEEN</code>操作符，语法略有不同，需要两个值</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_price BETWEEN 5 AND 10;</span><br></pre></td></tr></table></figure></div>

<p>​	检索prod_price在5到10之间的行</p>
<p>使用<code>BETWEEN</code>时必须指定两个值(所需范围的最低值和最高值)，并用AND分隔</p>
<p>BETWEEN匹配的范围包括开始值和结束值</p>
<h3 id="空值检查"><a href="#空值检查" class="headerlink" title="空值检查"></a>空值检查</h3><p>创建表时可指定其中类是否可包含空值</p>
<p>在一个列不包含值时，称其为包含空值NULL</p>
<p><code>IS NULL</code>子句：SELECT语句中用来检查具有NULL值的列的特殊WHERE子句</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_price IS NULL;</span><br></pre></td></tr></table></figure></div>

<p>​	返回prod_price为NULL的行</p>
<p><strong>NULL与不匹配</strong>：在匹配过滤或不匹配过滤时不返回具有NULL值的列</p>
<p>​	因此，过滤数据时，一定要验证返回数据中确实给出了呗过滤列具有NULL的行</p>
<hr>
<h1 id="数据过滤"><a href="#数据过滤" class="headerlink" title="数据过滤"></a>数据过滤</h1><p>组合WHERE子句以建立功能更强的更高级的搜索条件</p>
<h2 id="组合WHERE子句"><a href="#组合WHERE子句" class="headerlink" title="组合WHERE子句"></a>组合WHERE子句</h2><p>MySQL允许给出多个WHER子句</p>
<p>这些子句可以用两种方式使用：以AND子句 或 以RO子句的方式使用</p>
<p><strong>操作符</strong>：用来联结或改变WHERE子句中的子句的关键字，也称为逻辑操作符</p>
<h3 id="AND操作符"><a href="#AND操作符" class="headerlink" title="AND操作符"></a>AND操作符</h3><p>为通过不止一个列进行过滤，可使用AND操作符给WHERE子句附加条件</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_id, prod_price, prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_id = 1003 AND prod_price &lt;= 10;</span><br></pre></td></tr></table></figure></div>



<p>可以添加多个过滤条件，每添加一条就要使用一个AND</p>
<h3 id="OR操作符"><a href="#OR操作符" class="headerlink" title="OR操作符"></a>OR操作符</h3><p>与AND不同，指示MySQL检索匹配任一条件的行</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_id = 1002 OR vend_id = 1003;</span><br></pre></td></tr></table></figure></div>



<h3 id="计算次序"><a href="#计算次序" class="headerlink" title="计算次序"></a>计算次序</h3><p><strong>WHERE</strong>可包含任意数目的<strong>AND</strong>和<strong>OR</strong>操作符，允许两者结合以进行复杂和高级的过滤</p>
<p><strong>BUT！</strong>：SQL在处理OR操作符前，优先处理AND操作符</p>
<p>​	也就是说AND操作符的优先级比OR高(跟编程习惯反而不一样了)</p>
<p>解决方法：使用圆括号明确的分组相应的操作符</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE (vend_id = 1002 OR vend_id = 1003) AND prod_price &gt;= 10;</span><br></pre></td></tr></table></figure></div>

<p>​	此时，DBMS先过滤括号内的OR条件</p>
<p><strong>在WHERE子句中使用圆括号</strong>：任何时候使用具有AND和OR操作符的WHERE子句时，都应该使用圆括号明确的分组</p>
<p>​	可以消除歧义</p>
<h2 id="IN操作符"><a href="#IN操作符" class="headerlink" title="IN操作符"></a>IN操作符</h2><p>用来指定条件范围，范围中的每个条件都可以进行匹配</p>
<p>IN取合法值的由逗号分隔的清单，全都括在圆括号中</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_id IN (1002, 1003)</span><br><span class="line">ORDER BY prod_name;</span><br></pre></td></tr></table></figure></div>

<p>​	此SELECT检索vend_id为1002和1003的行</p>
<p><strong>IN</strong>：WHERE子句中用来指定要匹配值的清单的关键字，功能与OR相当</p>
<p>IN操作符的优点：</p>
<ul>
<li>在使用长的合法选项的清单时，IN的语法更清楚直观</li>
<li>使用IN时，计算的次序更容易管理(使用的操作符少)</li>
<li>IN操作符一般必OR操作符清单执行更快</li>
<li>IN最大的优点：可以包含其他SELECT语句，使得能够更动态的建立WHERE子句</li>
</ul>
<h2 id="NOT操作符"><a href="#NOT操作符" class="headerlink" title="NOT操作符"></a>NOT操作符</h2><p>只有一个功能：否定它之后所跟的任何条件</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_id NOT IN (1002, 1003)</span><br><span class="line">ORDER BY prod_name;</span><br></pre></td></tr></table></figure></div>

<p>​	NOT否定跟在它之后的条件，不匹配1002和1003</p>
<p>为什么使用NOT：</p>
<p>​	在复杂的语句中，在与IN操作符联合使用时，NOT找出与条件列表不匹配的行非常简单</p>
<p><strong>MySQL中的NOT</strong>：MySQL支持使用<strong>NOT</strong>对<strong>IN</strong>、<strong>BETWEEN</strong>和<strong>EXISTS</strong>子句取反</p>
<p>​	这与多数其他DBMS允许使用NOT对各种条件取反有很大差别</p>
<hr>
<h1 id="用通配符进行过滤"><a href="#用通配符进行过滤" class="headerlink" title="用通配符进行过滤"></a>用通配符进行过滤</h1><p>如何使用通配符进行通配搜索，以便对数据进行复杂过滤</p>
<h2 id="LIKE操作符"><a href="#LIKE操作符" class="headerlink" title="LIKE操作符"></a>LIKE操作符</h2><p>前述的所有操作符都是针对已知进行过滤的</p>
<p><strong>通配符</strong>：用来匹配值的一部分的特殊字符</p>
<p><strong>搜索模式</strong>：由字面值、通配符或两者组合构成的搜索条件</p>
<p>通配符本身实际是SQL的<strong>WHERE</strong>子句中有特殊含义的字符，SQL支持几种通配符</p>
<p>为在搜索子句中使用通配符，必须使用LIKE操作符</p>
<p>​	LIKE指示MySQL，后跟的搜索模式利用<strong>通配符匹配</strong>而不是<strong>直接相等匹配</strong>进行比较</p>
<p><strong>谓词</strong>：操作符在它作为谓词时不是操作符</p>
<p>​	技术上说，LIKE是谓词而不是操作符，虽然最终结果是相同的</p>
<h3 id="百分号-通配符"><a href="#百分号-通配符" class="headerlink" title="百分号(%)通配符"></a>百分号(%)通配符</h3><p>最常使用的通配符，**%**表示任何字符出现任意次数</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_idm prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_name LINK &#x27;jet%&#x27;;</span><br></pre></td></tr></table></figure></div>

<p>​	将检索任意以jet起头的词，%告诉MySQL接受jet之后的任意字符，不管它有多少字符</p>
<p><strong>区分大小写</strong>：根据MySQL的配置方式，搜索可以是区分大小写的</p>
<p>通配符可在搜索模式中任意位置使用，并可使用多个通配符：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_id, prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_name LIKE &#x27;%anvil%&#x27;;</span><br></pre></td></tr></table></figure></div>

<p>通配符也可以出现在搜索模式的中间，虽然这样做不太有用：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_name LIKE &#x27;s%e&#x27;;</span><br></pre></td></tr></table></figure></div>



<p>注意：除了一个或多个字符外，**%**还能匹配0个字符</p>
<p><strong>注意尾空格</strong>：尾空格可能会干扰通配符匹配</p>
<p>​	如：匹配anvil时，如果它后面有一个或多个空格，则子句<code>WHERE prod_name LIKE &#39;%anvil&#39;</code>将不会匹配它们，因为在最后的<code>l</code>后有多余的字符</p>
<p>​	解决的简单方法：在搜索模式最后附加一个**%**</p>
<p>​	更好的方法是使用函数去掉首尾空格</p>
<p><strong>注意NULL</strong>：虽然**%**通配符似乎可以匹配任何东西，但不能匹配NULL</p>
<p>​	即使是<code>WHERE prod_name LIKE &#39;%&#39;</code>也不能匹配NULL值</p>
<h3 id="下划线-通配符"><a href="#下划线-通配符" class="headerlink" title="下划线(_)通配符"></a>下划线(_)通配符</h3><p>用途与**%**一样，但下划线只能匹配单个字符而不是多个字符</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_id, prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_name LIKE &#x27;_ ton anvil&#x27;;</span><br></pre></td></tr></table></figure></div>

<p>​	与**%<strong>能匹配0个字符不一样，</strong>_**总是匹配一个字符，不能多也不能少</p>
<h2 id="使用通配符的技巧"><a href="#使用通配符的技巧" class="headerlink" title="使用通配符的技巧"></a>使用通配符的技巧</h2><p>MySQL的通配符很有用，但是有代价：</p>
<p>​	通配符搜索的处理一般要比前面的其他搜索所花费时间更长</p>
<p>一些使用通配符的技巧：</p>
<ul>
<li><p>不要过度使用通配符：如果其他操作符能达到相同目的，应该使用其他操作符</p>
</li>
<li><p>在确实需要使用通配符是：除非绝对有必要，否则不要把它们用到搜索模式的开始初</p>
<p>把通配符置于搜索模式的开始初，搜索起来是最慢的</p>
</li>
<li><p>仔细注意通配符的位置：如果放错地方，可能不会返回想要的数据</p>
</li>
</ul>
<p>总之，通配符是一种及其重要和有用的搜索工具</p>
<hr>
<h1 id="用正则表达式进行搜索"><a href="#用正则表达式进行搜索" class="headerlink" title="用正则表达式进行搜索"></a>用正则表达式进行搜索</h1><p>在MySQL WHERE子句内使用正则表达式来更好的控制数据过滤</p>
<h2 id="正则表达式介绍"><a href="#正则表达式介绍" class="headerlink" title="正则表达式介绍"></a>正则表达式介绍</h2><p>正则表达式：用来匹配文本的特殊的串(字符集合)</p>
<p>正则表达式用正则表达式语言来建立</p>
<p>(此处只介绍了正则表达式的基础知识)</p>
<h2 id="使用MySQL正则表达式"><a href="#使用MySQL正则表达式" class="headerlink" title="使用MySQL正则表达式"></a>使用MySQL正则表达式</h2><p>正则表达式的作用是匹配文本，将一个模式(正则表达式)与一个文本串进行比较</p>
<p>MySQL用SHERE子句对正则表达式提供了初步支持：允许指定正则表达式过滤SELECT检索出的数据</p>
<p><strong>仅为正则表达式语言的一个子集</strong>：MySQL仅支持多数正则表达式实现的一个很小的子集</p>
<h3 id="基本字符匹配"><a href="#基本字符匹配" class="headerlink" title="基本字符匹配"></a>基本字符匹配</h3><p>检索列prod_name包含文本1000的所有行：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_nameREGEXP &#x27;1000&#x27;</span><br><span class="line">ORDER BY prod_name;</span><br></pre></td></tr></table></figure></div>

<p>​	REGEXP后所跟的东西作为正则表达式处理</p>
<p>如：<code>WHERE prod_name REGEXP &#39;.000&#39;</code></p>
<p><code>.</code>是正则表达式语言中一个特殊的字符，表示匹配任意一个字符</p>
<p><strong>LIKE与REGEXP</strong>：之间有一个重要的差别</p>
<p>​	LIKE匹配整个列：如果被匹配的文本在列值内部出现，则LIKE将不会找到它，相应的行也不会被返回(除非使用通配符)</p>
<p>​	而REGEXP在列值内进行匹配，如果被匹配文本在列值中出现，则会被找到并返回</p>
<p>REGEXP也可以用来匹配整个列值(起到与LIKE相同的作用)：使用<code>^</code>和<code>$</code>定位符即可</p>
<p><strong>匹配不区分大小写</strong>：MySQL中的正则表达式匹配(自版本3.23.4后)不区分大小写</p>
<p>​	为区分大小写，可使用BINARY关键字，如：<code>WHERE prod_name REGEXP BINARY &#39;JetPack .000&#39;</code></p>
<h3 id="进行OR匹配"><a href="#进行OR匹配" class="headerlink" title="进行OR匹配"></a>进行OR匹配</h3><p>为搜索两个串之一，使用<code>|</code></p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_name REGEXP &#x27;1000|2000&#x27;</span><br><span class="line">ORDER BY prod_name;</span><br></pre></td></tr></table></figure></div>

<p>​	<code>|</code>为正则表达式的OR操作符，表示匹配其中之一</p>
<p>使用上类似OR语句，多个OR条件可并入单个正则表达式</p>
<p><strong>两个以上的OR条件</strong>：可以给出两个以上的OR条件</p>
<p>​	如：<code>&#39;1000 | 2000 | 3000&#39;</code>将匹配1000或2000或3000</p>
<h3 id="匹配几个字符之一"><a href="#匹配几个字符之一" class="headerlink" title="匹配几个字符之一"></a>匹配几个字符之一</h3><p>匹配任何单一字符，若只想匹配特定的字符：可以通过指定一组用<code>[</code>和<code>]</code>括起来的字符来完成</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_name REGEXP &#x27;[123] Ton&#x27;</span><br><span class="line">ORDER BY prod_name;</span><br></pre></td></tr></table></figure></div>

<p>​	<code>[123]</code>定义一组字符，意思是匹配1或2或3</p>
<p><code>[]</code>是另一种形式的OR语句</p>
<p>事实上，正则表达式<code>[123]Ton</code>为<code>[1|2|3]Ton</code>的缩写，也可以用后者</p>
<p>但，需要用<code>[]</code>来定义OR语句查找什么</p>
<p>若为：<code>WHERE prod_name REGEXP &#39;1|2|3 Ton&#39;</code>则会被假定为’1’或’2’或’3 Ton’</p>
<p>除非把字符<code>|</code>括在一个集合中，否则它将应用于整个串</p>
<p>字符集合也可以被否定，它们将匹配除指定字符外的任何东西</p>
<p>为否定一个字符集，在集合的开始处放置一个<code>^</code>即可，即：<code>[^123]</code>，匹配除字符1、2、3外的任何东西</p>
<h3 id="匹配范围"><a href="#匹配范围" class="headerlink" title="匹配范围"></a>匹配范围</h3><p>集合可用来定义要匹配的一个或多个字符</p>
<p>如：<code>[0123456789]</code>匹配数字0到9</p>
<p>为简化这种类型的集合，可使用<code>-</code>来定义一个范围：</p>
<p>​	<code>[0-9]</code>功能等同于上述数字列表</p>
<p>范围不限于完整的集合：<code>[1-3]</code>或<code>[6-9]</code>也合法</p>
<p>范围不一定只是数值的：<code>[a-z]</code>匹配任意字母字符</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_name REGEXP &#x27;[1-5] Ton&#x27;</span><br><span class="line">ORDER BY prod_name;</span><br></pre></td></tr></table></figure></div>

<p>​	<code>[1-5]</code>定义了一个范围，匹配1到5</p>
<h3 id="匹配特殊字符"><a href="#匹配特殊字符" class="headerlink" title="匹配特殊字符"></a>匹配特殊字符</h3><p>正则表达式语言由具有特定含义的特殊字符构成，如：<code>.</code>、<code>[]</code>、<code>|</code>、<code>-</code>等</p>
<p>如果要匹配这些特殊字符，必须用<code>\\</code>为前导</p>
<p><code>\\-</code>表示查找<code>-</code></p>
<p><code>\\.</code>表示查找<code>.</code></p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_name</span><br><span class="line">FROM vendors</span><br><span class="line">WHERE vend_name REGEXP &#x27;\\.&#x27;</span><br><span class="line">ORDER BY vend_name;</span><br></pre></td></tr></table></figure></div>

<p>​	这种处理就是所谓的转义，正则表达式内具有特殊意义的所有字符都必须以这种方式转义</p>
<p><code>\\</code>也用来引用元字符(具有特殊含义的字符)</p>
<p>表 空白元字符：</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td>\\f</td>
<td align="left">换页</td>
</tr>
<tr>
<td>\\n</td>
<td align="left">换行</td>
</tr>
<tr>
<td>\\r</td>
<td align="left">回车</td>
</tr>
<tr>
<td>\\t</td>
<td align="left">制表</td>
</tr>
<tr>
<td>\\v</td>
<td align="left">纵向制表</td>
</tr>
</tbody></table>
<p><strong>匹配\</strong>：为了匹配反斜杠(\)字符本身，需要使用\\\</p>
<p>**\或\\?**：多数正则表达式实现使用单个反斜杠转义特殊字符，以便能使用这些字符本身</p>
<p>​	但MySQL要求两个反斜杠(MySQL自己解释一个，正则表达式库解释另一个)</p>
<h3 id="匹配字符类"><a href="#匹配字符类" class="headerlink" title="匹配字符类"></a>匹配字符类</h3><p>为更方便工作，可以使用预定义的字符集，称为字符类</p>
<p>表 字符类：列出了字符类以及含义</p>
<table>
<thead>
<tr>
<th>类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>[:alnum:]</code></td>
<td>任意字母和数字（同[a-zA-Z0-9]）</td>
</tr>
<tr>
<td><code>[:alpha:]</code></td>
<td>任意字符（同[a-zA-Z]）</td>
</tr>
<tr>
<td><code>[:blank:]</code></td>
<td>空格和制表（同[\t]）</td>
</tr>
<tr>
<td><code>[:cntrl:]</code></td>
<td>ASCII控制字符（ASCII 0到31和127）</td>
</tr>
<tr>
<td><code>[:digit:]</code></td>
<td>任意数字（同[0-9]）</td>
</tr>
<tr>
<td><code>[:graph:]</code></td>
<td>与[:print:]相同，但不包括空格</td>
</tr>
<tr>
<td><code>[:lower:]</code></td>
<td>任意小写字母（同[a-z]）</td>
</tr>
<tr>
<td><code>[:print:]</code></td>
<td>任意可打印字符</td>
</tr>
<tr>
<td><code>[:punct:]</code></td>
<td>既不在[:alnum:]又不在[:cntrl:]中的任意字符</td>
</tr>
<tr>
<td><code>[:space:]</code></td>
<td>包括空格在内的任意空白字符（同[\f\n\r\t\v]）</td>
</tr>
<tr>
<td><code>[:upper:]</code></td>
<td>任意大写字母（同[A-Z]）</td>
</tr>
<tr>
<td><code>[:xdigit:]</code></td>
<td>任意十六进制数字（同[a-fA-F0-9]）</td>
</tr>
</tbody></table>
<h3 id="匹配多个实例"><a href="#匹配多个实例" class="headerlink" title="匹配多个实例"></a>匹配多个实例</h3><p>目前为止使用的所有正则表达式都试图匹配单次出现</p>
<p>有时需要对匹配的数目进行更强的控制，如：可能需要寻找所有的数，不管数中包含多少数字</p>
<p>可以用下表列出的正则表达式重复元字符来完成</p>
<p>表 重复元字符：</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>*</code></td>
<td align="left">0个或多个匹配</td>
</tr>
<tr>
<td><code>+</code></td>
<td align="left">1个或多个匹配（等于{1,}）</td>
</tr>
<tr>
<td><code>？</code></td>
<td align="left">0个或1个匹配（等于{0,1}）</td>
</tr>
<tr>
<td><code>&#123;n&#125;</code></td>
<td align="left">指定数目的匹配</td>
</tr>
<tr>
<td><code>&#123;n,&#125;</code></td>
<td align="left">不少于指定数目的匹配</td>
</tr>
<tr>
<td><code>&#123;n,m&#125;</code></td>
<td align="left">匹配数目的范围（m不超过255）</td>
</tr>
</tbody></table>
<p>例1</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_name REGEXP &#x27;\\([0-9] sticks?\\)&#x27;</span><br><span class="line">ORDER BY prod_name;</span><br></pre></td></tr></table></figure></div>

<p>​	正则表达式<code>\\([0-9] sticks?\\)</code></p>
<ul>
<li><code>\\(</code>：匹配<code>)</code></li>
<li><code>[0-9]</code>：匹配任意数字</li>
<li><code>sticks?</code>：匹配stick和sticks(s后面的?使s可选)</li>
<li><code>\\)</code>：匹配<code>)</code></li>
</ul>
<p>没有?，匹配stick和sticks会非常困难</p>
<p>例2</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_name REGEXP &#x27;[[:digit:]]&#123;4&#125;&#x27;</span><br><span class="line">ORDER BY prod_name;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>[:digit:]</code>：匹配任意数字</li>
<li><code>&#123;4&#125;</code>确切的要求前面的字符(任意数字)出现4次</li>
</ul>
<p>即匹配连在一起的任意四位数字</p>
<p>需要注意的是，在使用正则表达式时，编写某个特殊的表达式几乎总是有不止一种方法</p>
<p>比如上面的例子可以写为：<code>WHERE prod_name REGEXP &#39;[0-9][0-9][0-9][0-9]&#39;</code></p>
<h3 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h3><p>目前为止的所有例子都是匹配一个串中任意位置的文本</p>
<p>为匹配特定位置的文本，需要使用下表列出的定位符</p>
<p>表 定位元字符</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>^</code></td>
<td>文本的开始</td>
</tr>
<tr>
<td><code>$</code></td>
<td>文本的结尾</td>
</tr>
<tr>
<td><code>[[:&lt;:]]</code></td>
<td>词的开始</td>
</tr>
<tr>
<td><code>[[:&gt;:]]</code></td>
<td>词的结尾</td>
</tr>
</tbody></table>
<p>例如，想找出以一个数(包括以小数点开始的数)开始的所有产品</p>
<p>简单搜索<code>[0-9\\.]</code>(或<code>[[:digit:]\\.]</code>)不行，因为它将在文本内任意位置查找匹配</p>
<p>解决办法是使用<code>^</code>定位符：</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_name REGEXP &#x27;^[0-9\\.]&#x27;</span><br><span class="line">ORDER BY prod_name</span><br></pre></td></tr></table></figure></div>

<p>​	<code>^</code>匹配串的开始，因此<code>^[0-9\\.]</code>只在<code>.</code>或任意数字为串中第一个字符时才匹配它们</p>
<p>​	没有<code>^</code>，则还要多检索那些中间有数字的行</p>
<p><strong><code>^</code>的双重用途</strong>：<code>^</code>有两种用法</p>
<ul>
<li>在集合中(用<code>[</code>和<code>]</code>定义)，用它来否定该集合</li>
<li>否则，用来指串的开始处</li>
</ul>
<p><strong>使REGEXP起类似LIKE的作用</strong>：前面说过，LIKE和REGEXP的不同在于：LIKE匹配整个串而REGEXP匹配子串</p>
<p>​	利用定位符，通过用<code>^</code>开始每个表达式，用<code>$</code>结束每个表达式，可以使REGEXP的作用与LIKE一样</p>
<p><strong>简单的正则表达式测试</strong>：可以在不使用数据库表的情况下用SELECT来测试正则表达式</p>
<p>​	REGEXP检查总是返回0(没有匹配)或1(匹配)</p>
<p>​	可以用带文字串的REGEXP来测试表达式，并试验它们</p>
<p>​		相应的语法如下：</p>
<p>​		<code>SELECT &#39;hello&#39; REGEXP &#39;[0-9]&#39;;</code></p>
<p>​		这个例子显然将返回0(因为文本hello中没有数字)</p>
<hr>
<h1 id="创建计算字段"><a href="#创建计算字段" class="headerlink" title="创建计算字段"></a>创建计算字段</h1><p>介绍什么是计算字段，如何创建计算字段，怎样从应用程序中使用别名引用它们</p>
<h2 id="计算字段"><a href="#计算字段" class="headerlink" title="计算字段"></a>计算字段</h2><p>存储在数据库表中的数据一般不是应用程序所需要的格式</p>
<p>我们需要直接从数据库中检索出转换、计算、格式化过的数据，而不是检索出数据，然后在客户机应用程序中重新格式化</p>
<p>此时应使用计算字段</p>
<p>计算字段并不实际存在于数据库表中</p>
<p>计算字段是运行时在SELECT语句内创建的</p>
<p><strong>字段</strong>：基本上与列意思相同，经常互换使用</p>
<p>​	不过数据库列一般称为列，而术语字段通常用在计算字段的连接上</p>
<p>只有数据库知道SELECT语句中哪些列是实际的表列，哪些列是计算字段</p>
<p>从客户机的角度看，计算字段的数据是以与其他列的数据相同的方式返回的</p>
<p><strong>客户机与服务器的格式</strong>：可在SQL语句内完成的许多转换和格式化工作都可以直接在客户机应用程序内完成</p>
<p>​	但一般在数据库服务器上完成这些操作要快得多，因为DBMS是设计来快速有效的完成这种处理的</p>
<h2 id="拼接字段"><a href="#拼接字段" class="headerlink" title="拼接字段"></a>拼接字段</h2><p><strong>拼接</strong>：将值联结到一起构成单个值</p>
<p>例：将vend_name和vend_country以name(loaction)这样的格式返回</p>
<p>解决办法：将两个列拼接起来</p>
<p>在MySQL的SELECT语句中，可以使用<code>Concat()</code>函数来拼接两个列</p>
<p><strong>MySQL的不同之处</strong>：多数DBMS使用<code>+</code>或<code>||</code>来实现拼接，MySQL则使用<code>Concat()</code>函数来实现</p>
<p>​	当把SQL语句转换成MySQL语句时要注意</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT Concat(vend_name, &#x27; (&#x27;, vend_country, &#x27;)&#x27;)</span><br><span class="line">FROM vendors</span><br><span class="line">ORDER BY vend_name;</span><br></pre></td></tr></table></figure></div>

<p>​	<code>Concat()</code>拼接串，把多个串连接起来形成一个较长的串</p>
<p>​	需要一个或多个指定的串，各个串之间用逗号分隔</p>
<p>删除数据右侧多余的空格来整理数据，这可以使用MySQL的<code>RTrim()</code>函数来完成</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT Concat(RTrim(vend_name), &#x27; (&#x27;, RTrim(vend_country), &#x27;)&#x27;)</span><br><span class="line">FROM vendors</span><br><span class="line">ORDER BY vend_name;</span><br></pre></td></tr></table></figure></div>

<p>​	<code>RTrim()</code>函数去掉值右边的所有空格</p>
<p>​	通过使用<code>RTrim()</code>各个列都进行了整理</p>
<p><strong><code>Trim</code>函数</strong>：MySQL除了支持<code>RTrim()</code>(去除串右边的空格)</p>
<p>​	还支持<code>LTrim()</code>(去掉串左边的空格)</p>
<p>​	以及<code>Trim()</code>(去掉串左右两边的空格)</p>
<p><strong>使用别名</strong></p>
<p>前面的输出中，SELECT语句拼接地址字段后得到的新计算列没有名字</p>
<p>一个未命名的列不能用于客户机应用中，因为客户机没有办法引用它</p>
<p>为解决此问题，SQL支持列别名</p>
<p><em>别名</em>：是一个字段或值的替换名</p>
<p>别名用<code>AS</code>关键字赋予</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT Concat(RTrim(vend_name), &#x27; (&#x27;, RTrim(vend_country), &#x27;)&#x27;) AS vend_title</span><br><span class="line">FROM vendors</span><br><span class="line">ORDER BY vend_name;</span><br></pre></td></tr></table></figure></div>

<p>​	<code>AS vend_title</code>指示SQL创建一个包含指定计算的名为vend_title的计算字段</p>
<p><strong>别名的其他用途</strong>：常见的用途包括，</p>
<ul>
<li>在实际的表列名包含不符合规定的字符(如空格)时重新命名它</li>
<li>在原来的名字含混或容易误解时扩充它，等等</li>
</ul>
<p><strong>导出列</strong>：别名有时也称为导出列，不管称为什么，它们所代表的都是相同的东西</p>
<h2 id="执行算数计算"><a href="#执行算数计算" class="headerlink" title="执行算数计算"></a>执行算数计算</h2><p>计算字段的另一常见用途：对检索出的数据进行算数计算</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_id,</span><br><span class="line">       quantity,</span><br><span class="line">       item_price,</span><br><span class="line">       quantity*item_price AS expanded_price</span><br><span class="line">FROM orderitems</span><br><span class="line">WHERE order_num = 20005;</span><br></pre></td></tr></table></figure></div>

<p>​	expanded_price列为一个计算字段，此计算为quantity * item_price</p>
<p>MySQL支持下表中列出的基本算术操作符</p>
<p>此外，圆括号可用来区分优先顺序</p>
<p>表 MySQL算术操作符：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>+</code></td>
<td>加</td>
</tr>
<tr>
<td><code>-</code></td>
<td>减</td>
</tr>
<tr>
<td><code>*</code></td>
<td>乘</td>
</tr>
<tr>
<td><code>/</code></td>
<td>除</td>
</tr>
</tbody></table>
<p><strong>如何测试计算</strong>：SELECT提供了册数和试验函数与计算的一个很好的办法</p>
<p>​	SELECT通常用来从表中检索数据，但可以省略FROM子句以便简单的访问和处理表达式</p>
<p>例：</p>
<ul>
<li><code>SELECT 3*2;</code>将返回6</li>
<li><code>SELECT Trim(&#39;abc&#39;);</code>将返回abc</li>
<li><code>SELECT Now()</code>利用<code>Now()</code>函数返回当前日期和时间</li>
</ul>
<hr>
<h1 id="使用数据处理函数"><a href="#使用数据处理函数" class="headerlink" title="使用数据处理函数"></a>使用数据处理函数</h1><p>什么是函数，MySQL支持何种函数，如何使用这些函数</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>SQL支持利用函数来处理数据</p>
<p>函数一般是在数据上执行的，给数据的转换和处理提供了方便</p>
<p><strong>函数没有SQL的可移植性强</strong>：多数SQL语句是可移植的，在SQL实现之间有差异时，这些差异通常不那么难处理</p>
<p>​	但函数的可移植性却不强，几乎每中主要的DBMS的实现都支持其他实现不支持的函数，而且有时差异还很大</p>
<p>​	不使用特殊实现的功能虽然很有好处，但不总是利于应用程序的性能，如果不使用这些函数，编写某些和应用程序代码会很艰难，必须用其他方法来失效DBMS有效的完成的工作</p>
<p>​	如果决定使用函数，应该保证做好代码注释，以便以后能确切的知道所编写SQL代码的含义</p>
<h2 id="使用函数"><a href="#使用函数" class="headerlink" title="使用函数"></a>使用函数</h2><p>多数SQL实现支持以下类型的函数：</p>
<ul>
<li>用于处理文本串(如删除、填充值、转换值为大写或小写)的文本函数</li>
<li>用于在数值数据上进行算数操作(如返回绝对值，进行代数运算)的数组函数</li>
<li>用于处理日期和时间值，并从这些值中提取特定成分(如，返回两个日期之差，检查日期有效性等)的日期和时间函数</li>
<li>返回DBMS正使用的特殊信息(如返回用户登录信息，检查版本细节)的系统函数</li>
</ul>
<h3 id="文本处理函数"><a href="#文本处理函数" class="headerlink" title="文本处理函数"></a>文本处理函数</h3><p>例：使用<code>Upper()</code>函数</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECt vend_name, Upper(vend_name) AS vend_name_upcase</span><br><span class="line">FROM vendors</span><br><span class="line">ORDER BY vend_name;</span><br></pre></td></tr></table></figure></div>

<p>​	<code>Upper()</code>将文本转换为大写</p>
<p>下表列出了某些常用的文本处理函数：</p>
<p>表 常用的文本处理函数</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Left()</code></td>
<td>返回串左边的字符</td>
</tr>
<tr>
<td align="left"><code>Length()</code></td>
<td>返回串的长度</td>
</tr>
<tr>
<td align="left"><code>Locate()</code></td>
<td>找出串的一个子串</td>
</tr>
<tr>
<td align="left"><code>Lower()</code></td>
<td>将串转换为小写</td>
</tr>
<tr>
<td align="left"><code>LTrim()</code></td>
<td>去掉串左边的空格</td>
</tr>
<tr>
<td align="left"><code>Right()</code></td>
<td>返回串右边的字符</td>
</tr>
<tr>
<td align="left"><code>RTrim()</code></td>
<td>去掉串右边的空格</td>
</tr>
<tr>
<td align="left"><code>Soundex()</code></td>
<td>返回串的SOUNDEX值</td>
</tr>
<tr>
<td align="left"><code>SubString()</code></td>
<td>返回子串的字符</td>
</tr>
<tr>
<td align="left"><code>Upper()</code></td>
<td>将串转换为大写</td>
</tr>
</tbody></table>
<p><strong>SOUNDEX</strong>是一个将任何文本串转换为描述其语音表示的字母数字模式的算法</p>
<p><strong>SOUBDEX</strong>考虑了类似的发音字符和音节，使得能对穿进行发音比较二不是字母比较</p>
<p>虽然<strong>SOUNDEX</strong>不是SQL概念，但MySQL(像多数DBMS一样)都提供对<strong>SOUNDEX</strong>的支持</p>
<p>使用<code>Soundex()</code>函数的例子：</p>
<p>有个顾客联系名为<code>Y.Lee</code>，但如果是输入错误，此联系名时间应该是<code>Y.Lie</code>怎么办：</p>
<p>使用<code>Soundex()</code>函数进行搜索，匹配所有发音类似于<code>Y.Lie</code>的联系名：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name, cust_contact</span><br><span class="line">FROM customers</span><br><span class="line">WHERE Soundex(cust_contact) = Soundex(&#x27;Y Lie&#x27;);</span><br></pre></td></tr></table></figure></div>

<p>​	WHERE子句使用<code>Soundex()</code>函数来转换cust_contact列值和搜索为它们的<strong>SOUNDEX</strong>值</p>
<p>最终搜索出了发音相似的<code>Y.Lee</code>，<strong>SOUNDEX</strong>值相匹配</p>
<h3 id="日期和时间处理函数"><a href="#日期和时间处理函数" class="headerlink" title="日期和时间处理函数"></a>日期和时间处理函数</h3><p>日期和时间采用相应的数据类型和特殊的格式存储，以便能快速和有效的排序或过滤，并节省物理存储空间</p>
<p>一般，应用程序不使用用来存储日期和时间的格式，因此日期和时间函数总是被用来读取、统计、处理这些值</p>
<p>下表列出了某些常用的日期和时间处理函数</p>
<p>表 常用日期和时间处理函数</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>AddDate()</code></td>
<td>增加一个日期（天、周等）</td>
</tr>
<tr>
<td align="left"><code>AddTime()</code></td>
<td>增加一个时间（时、分等）</td>
</tr>
<tr>
<td align="left"><code>CurDate()</code></td>
<td>返回当前日期</td>
</tr>
<tr>
<td align="left"><code>CurTime()</code></td>
<td>返回当前时间</td>
</tr>
<tr>
<td align="left"><code>Date()</code></td>
<td>返回日期时间的日期部分</td>
</tr>
<tr>
<td align="left"><code>DateDiff()</code></td>
<td>计算两个日期之差</td>
</tr>
<tr>
<td align="left"><code>Date_Add()</code></td>
<td>高度灵活的日期运算函数</td>
</tr>
<tr>
<td align="left"><code>Date_Format()</code></td>
<td>返回一个格式化的日期或时间串</td>
</tr>
<tr>
<td align="left"><code>Day()</code></td>
<td>返回一个日期的天数部分</td>
</tr>
<tr>
<td align="left"><code>DayOfWeek()</code></td>
<td>对于一个日期，返回对应的星期几</td>
</tr>
<tr>
<td align="left"><code>Hour()</code></td>
<td>返回一个时间的小时部分</td>
</tr>
<tr>
<td align="left"><code>Minute()</code></td>
<td>返回一个时间的分钟部分</td>
</tr>
<tr>
<td align="left"><code>Month()</code></td>
<td>返回一个日期的月份部分</td>
</tr>
<tr>
<td align="left"><code>Now()</code></td>
<td>返回当前日期和时间</td>
</tr>
<tr>
<td align="left"><code>Second()</code></td>
<td>返回一个时间的秒部分</td>
</tr>
<tr>
<td align="left"><code>Time()</code></td>
<td>返回一个日期时间的时间部分</td>
</tr>
<tr>
<td align="left"><code>Year()</code></td>
<td>返回一个日期的年份部分</td>
</tr>
</tbody></table>
<p>用日期进行过滤需要注意一些别的问题和使用特殊的MySQL函数</p>
<p>首先注意MySQL使用的日期格式：</p>
<p>​	无论什么时候指定一个日期，不管是插入或更新标值还是用WHERE子句进行过滤，日期必须为格式<code>yyyy-mm-dd</code></p>
<p>​	虽然其他的日期格式可能也行，但这是首选的日期格式，排除了多义性</p>
<p><strong>应该总是使用4为数字的年份</strong>：支持2位数的年份</p>
<p>​	MySQL处理<code>00-69</code>为<code>2000-2069</code>，处理<code>70-99</code>为<code>1970-1999</code></p>
<p>​	虽然可能是打算要的年份，但使用完整的4位数字年份更可靠，因为MySQL不必做出任何假定</p>
<p>因此，基本的日期比较应该很简单：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_id, order_num</span><br><span class="line">FROM orders</span><br><span class="line">WHERE order_date = &#x27;2005-09-01&#x27;;</span><br></pre></td></tr></table></figure></div>

<p>​	检索出order_date为<code>2005-09-01</code>的行</p>
<p>但，时间值在实际中很可能并不总是这样(如：<code>2005-09-01 11:30:05</code>)，此时不会检索出来</p>
<p>解决办法：指示MySQL仅将给出的日期与列中的日期部分进行比较，而不是将给出的日期与整个列值进行比较</p>
<p>​	为此，必须使用<code>Date()</code>函数</p>
<p><code>Date(order_date)</code>只是MySQL仅提取列的日期部分，</p>
<p>更可靠的SELECT语句为：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_id, order_num</span><br><span class="line">FROM orders</span><br><span class="line">WHERE Date(order_date) = &#x27;2005-09-01&#x27;;</span><br></pre></td></tr></table></figure></div>

<p>**如果要的是日期，请使用<code>Date()</code>**：如果想要的仅是日期，则使用<code>Date()</code>是一个良好的习惯，即使知道相应的列只包含日期也是如此</p>
<p>​	这样，如果由于某种原因表中以后有日期和时间值，SQL代码也不用改变</p>
<p>​	当然，也存在一个<code>Time()</code>函数，在只想要时间时应该使用它</p>
<p><code>Date()</code>和<code>Time()</code>都是在MySQL4.1.1中第一次引入的</p>
<p>若想检索出2005年9月下的所有订，简单的相等测试不行，因为要匹配月份中的天数</p>
<p>有几种解决方法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_id, order_num</span><br><span class="line">FROM orders</span><br><span class="line">WHERE Date(order_date) BETWEEN &#x27;2005-09-01&#x27; AND &#x27;2005-09-30&#x27;;</span><br></pre></td></tr></table></figure></div>

<p>​	BETWEEN操作符定义了一个要匹配的日期范围</p>
<p>另一种办法(不需要记住每个月有多少天，或不需要担心闰年二月的方法)：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_id, order_num</span><br><span class="line">FROM orders</span><br><span class="line">WHERE Year(order_date) = 2005 AND Month(order_date) = 9;</span><br></pre></td></tr></table></figure></div>

<p>​	<code>Year()</code>是一个从日期(或日期时间)中返回年份的函数</p>
<p>​	<code>Month()</code>从日期中返回月份</p>
<p><strong>MySQL的版本差异</strong>：MySQL4.1.1中增加了虚度日期和时间函数</p>
<p>​	如果使用更早的MySQL版本，应查阅文档以确定可以使用哪些函数</p>
<h3 id="数组处理函数"><a href="#数组处理函数" class="headerlink" title="数组处理函数"></a>数组处理函数</h3><p>数组处理函数仅处理数组数据</p>
<p>这些函数一般用于代数、三角、集合运算，没有串或日期-时间处理函数的使用那么频繁</p>
<p>BUT，在主要DBMS的函数中，数组函数是最一直最统一的函数，(怪搞笑的不是吗</p>
<p>表 常用数值处理函数</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Abs()</code></td>
<td>返回一个数的绝对值</td>
</tr>
<tr>
<td align="left"><code>Cos()</code></td>
<td>返回一个角度的余弦</td>
</tr>
<tr>
<td align="left"><code>Exp()</code></td>
<td>返回一个数的指数值</td>
</tr>
<tr>
<td align="left"><code>Mod()</code></td>
<td>返回除操作的余数</td>
</tr>
<tr>
<td align="left"><code>Pi()</code></td>
<td>返回圆周率</td>
</tr>
<tr>
<td align="left"><code>Rand()</code></td>
<td>返回一个随机数</td>
</tr>
<tr>
<td align="left"><code>Sin()</code></td>
<td>返回一个角度的正弦</td>
</tr>
<tr>
<td align="left"><code>Sqrt()</code></td>
<td>返回一个数的平方根</td>
</tr>
<tr>
<td align="left"><code>Tan()</code></td>
<td>返回一个角度的正切</td>
</tr>
</tbody></table>
<hr>
<h1 id="汇总数据"><a href="#汇总数据" class="headerlink" title="汇总数据"></a>汇总数据</h1><p>SQL的聚集函数以及如何用其进行汇总表的数据</p>
<h2 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h2><p>由于经常需要汇总数据而不用把它们实际检索出来，MySQL提供了专门的函数<br>使用这些函数，MySQL查询可用于检索数据，一边分析和报表生成<br>这种类型的检索例子有以下几种：</p>
<ul>
<li>确定表中行书(或满足猴哥条件或包含某个特定值的行数)</li>
<li>获得表中行组的和</li>
<li>找出表列(或索引行或某些特定的行)的最大值、最小值和平均值<br>以上例子都需要对表中数据(而不是实际数据本身)汇总<br>  因此，返回实际表数据是对时间和处理资源的一种浪费<br>  我们想要的是汇总信息<br>为了方便这种类型的检索，MySQL给出了5给聚集函数(见下表)，可进行上述罗列的检索</li>
</ul>
<p><strong>聚集函数</strong>：运行在行组上，计算和返回单个值的函数</p>
<p>表 SQL聚集函数</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>AVG()</code></td>
<td>返回某列的平均值</td>
</tr>
<tr>
<td><code>COUNT()</code></td>
<td>返回某列的行数</td>
</tr>
<tr>
<td><code>MAX()</code></td>
<td>返回某列的最大值</td>
</tr>
<tr>
<td><code>MIN()</code></td>
<td>返回某列的最小值</td>
</tr>
<tr>
<td><code>SUM()</code></td>
<td>返回某列值之和</td>
</tr>
</tbody></table>
<p><strong>标准偏差</strong>：MySQL还支持一系列的标准偏差聚集函数</p>
<h3 id="AVG-函数"><a href="#AVG-函数" class="headerlink" title="AVG()函数"></a><code>AVG()</code>函数</h3><p>通过对表中行书计数并计算特定列值之和，求得该列的平均值</p>
<ul>
<li>可用来返回所有列的平均值</li>
<li>也可以用来返回特定列或行的平均值</li>
</ul>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT AVG(prod_price) AS avg_price</span><br><span class="line">FROM products;</span><br></pre></td></tr></table></figure></div>
<pre><code>值avg_Price包含表中所有产品(prod_price)的平均值
avg_price是一个别名
</code></pre>
<p><code>AVG()</code>也可用来确定特定列或行的平均值<br>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT AVG(prod_price) AS avg_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_id = 1003;</span><br></pre></td></tr></table></figure></div>
<pre><code>与前一条相比包含了WHERE子句，因此avg_price中返回的值是特定列的平均值
</code></pre>
<p><strong>只用于单个列</strong>：<code>AVG()</code>只能用来确定特定数组列的平均值，且列名必须作为函数参数给出<br>    为获得多个列的平均值，必须使用多个<code>AVG()</code>函数</p>
<p><strong>NULL值</strong>：<code>AVG()</code>函数忽略列值为NULL的行</p>
<h3 id="COUNT-函数"><a href="#COUNT-函数" class="headerlink" title="COUNT()函数"></a><code>COUNT()</code>函数</h3><p>进行计数<br>可利用<code>COUNT()</code>确定表中行的数码或符合特定条件的行的数目</p>
<p><code>COUNT()</code>函数有两种使用方式：</p>
<ul>
<li>使用<code>COUNT(*)</code>对表中行的数目进行计数<br>  不管表列中包含的是空值(NULL)还是非空值</li>
<li>使用<code>COUNT(column)</code>对特定列中具有值的行进行计数<br>  忽略NULL值</li>
</ul>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*) AS num_cust</span><br><span class="line">FROM customers;</span><br></pre></td></tr></table></figure></div>
<pre><code>利用`COUNT(*)`对所有行计数，不管行中各列有什么值
计数值在num_cust中返回
</code></pre>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(cust_email) AS num_cust</span><br><span class="line">FROM customers;</span><br></pre></td></tr></table></figure></div>
<pre><code>对cust_email列中有值的行进行计数
</code></pre>
<p><strong>NULL值</strong>：如果指定列名，则指定列的值为空的行被<code>COUNT()</code>函数忽略<br>    但如果<code>COUNT()</code>函数中用的是星号(<code>*</code>)，则不忽略</p>
<h3 id="MAX-函数"><a href="#MAX-函数" class="headerlink" title="MAX()函数"></a><code>MAX()</code>函数</h3><p>返回指定列中的最大值<br><code>MAX()</code>要求指定列名：<br>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT MAX(prod_price) AS max_price</span><br><span class="line">FROM products;</span><br></pre></td></tr></table></figure></div>
<pre><code>`MAX()`返回表中最大值
</code></pre>
<p>**对非数值数据使用<code>MAX()</code>**：<code>MAX()</code>一般用来找出最大的数值或日期值<br>    但MySQL允许将它用来返回任意列中的最大值，包括返回文本列中的最大值<br>    在用于文本数据时，如果数据按相应的列排序，则<code>MAX()</code>返回最后一行</p>
<p><strong>NULL值</strong>：<code>MAX()</code>函数忽略列值为NULL的行</p>
<h3 id="MIN-函数"><a href="#MIN-函数" class="headerlink" title="MIN()函数"></a><code>MIN()</code>函数</h3><p>返回指定列的最小值<br>与<code>MAX()</code>用于，<code>MIN()</code>要求指定列名：<br>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT MIN(prod_price) AS min_price</span><br><span class="line">FROM products;</span><br></pre></td></tr></table></figure></div>

<p>**对非数值数据使用<code>MIN()</code>**：<code>MIN()</code>函数与<code>MAX()</code>类似<br>    MySQL允许使用其返回任意列中的最小值，包括文本列<br>    用于文本数据是，如果按相应的列排序，则返回最前面的行</p>
<p><strong>NULL值</strong>：<code>MIN()</code>函数忽略值为NULL的行</p>
<h3 id="SUM-函数"><a href="#SUM-函数" class="headerlink" title="SUM()函数"></a><code>SUM()</code>函数</h3><p>用来返回指定列的和(总计)<br>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT SUM(quantity) AS items_ordered</span><br><span class="line">FROM orderitems</span><br><span class="line">WHERE order_num = 20005;</span><br></pre></td></tr></table></figure></div>
<pre><code>函数`SUM(quantity)`返回quantity总和
WHERE子句限定了order_num的值
</code></pre>
<p><code>SUM()</code>也可以用来合计计算值<br>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT SUM(item_price*quantity) AS total_price</span><br><span class="line">FROM orderitems</span><br><span class="line">WHERE order_num = 2005;</span><br></pre></td></tr></table></figure></div>
<pre><code>函数`SUM(item_price*quantity)`返回其中计算结果的总和
</code></pre>
<p><strong>在多个列上进行计算</strong>：如上例所示<br>    利用标准的算数操作符，所有聚集函数都可用来执行多个列上的计算</p>
<p><strong>NULL值</strong>：<code>SUM()</code>函数忽略值为NULL的行</p>
<h2 id="聚集不同值"><a href="#聚集不同值" class="headerlink" title="聚集不同值"></a>聚集不同值</h2><p><strong>MySQL 5及后期版本</strong>：下面的聚集函数的<code>DISTINCT</code>的使用，以及被添加到MySQL 5.0.3中<br>    下面的内容在MySQL 4.x中不能正常运行</p>
<p>以上5给聚集函数都可以如下使用：</p>
<ul>
<li>对所有的行执行计算<br>  指定ALL参数或不给参数(因为ALL是默认行为)</li>
<li>值包含不同的值<br>  指定DISTINCT参数</li>
</ul>
<p><strong>ALL为默认</strong>：ALL参数不需要指定，因为它是默认行为<br>    如果不指定DISTINCT，则假定为ALL</p>
<p>下例，使用<code>AVG()</code>函数返回特定字段的产品平均值<br>与上面的SELECT语句相同，但使用了DISTINCT参数，因此平均值只考虑各个不同的值<br>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT AVG(DISTINCT prod_price) AS avg_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_id = 1003;</span><br></pre></td></tr></table></figure></div>
<pre><code>使用DISTINCT后，此例中的avg_price比较高
因为有多个物品具有相同的较低的价格，排除它们提升了平均价格
</code></pre>
<p><strong>注意</strong>：如果指定列名，则DISTINCT只能用于<code>COUNT()</code><br>    DISTINCT不能用于<code>COUNT(*)</code>，因此不允许使用<code>COUNT(DISTINCT)</code>，否则会产生错误<br>    类似的，DISTINCT必须使用列名，不能用于计算或表达式</p>
<p>**将DISTINCT用于<code>MIN()</code>和<code>MAX()</code>**：虽然DISTINCT从技术上可用于<code>MIN()</code>和<code>MAX()</code><br>    但这样做实际上没有价值…<br>    一个列中的最小值和最大值不管是否包含不同值都是相同的</p>
<h2 id="组合聚集函数"><a href="#组合聚集函数" class="headerlink" title="组合聚集函数"></a>组合聚集函数</h2><p>SELECT语句可根据需要包含多个聚集函数：<br>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*) AS num_items,</span><br><span class="line">	MIN(prod_price) AS price_min,</span><br><span class="line">	MAX(prod_price) AS price_max,</span><br><span class="line">	AVG(prod_price) AS price_avg</span><br><span class="line">FROM products;</span><br></pre></td></tr></table></figure></div>
<pre><code>这里用单条SELECT语句执行了4个聚集计算，返回4个值
</code></pre>
<p><strong>取别名</strong>：在指定别名以及包含某个聚集函数的结果时，不应该使用表中实际的列名<br>    虽然这样做并非不合法，但使用唯一的名字会使SQL更易于理解和使用(以及将来排除故障)</p>
<hr>
<h1 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h1><p>涉及两个新SELECT子句：<code>GROUP BY</code>子句和<code>HAVING</code>子句</p>
<h2 id="数据分组"><a href="#数据分组" class="headerlink" title="数据分组"></a>数据分组</h2><p>SQL聚集函数可用来汇总数据，但都是在表的所有数据或匹配特定的WHERE子句的数据上进行的</p>
<p>分组允许把数据分为多个逻辑组，以便能对每个分组进行聚集计算</p>
<h2 id="创建分组"><a href="#创建分组" class="headerlink" title="创建分组"></a>创建分组</h2><p>分组是在SELECT语句的<code>GROUP BY</code>子句中建立的<br>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_id, COUNT(*) AS num_prods</span><br><span class="line">FROM products</span><br><span class="line">GROUP BY vend_id;</span><br></pre></td></tr></table></figure></div>
<pre><code>`GROUP BY`子句指示MySQL按vend_id排序并分组数据
这导致对每个vend_id而不是整个表计算num_prods一次
</code></pre>
<p>因为使用了<code>GROUP BY</code>，就不必指定要计算和估值的每个组了，系统会自动完成<br><code>GROUP BY</code>子句指示MySQL分组数据，然后对<strong>每个组</strong>而不是<strong>整个结果集</strong>进行聚集</p>
<p>在具体使用·GROUP BY&#96;子句前，需要知道的一些重要规定：</p>
<ul>
<li><code>GROUP BY</code>子句可以包含任意数目的列<br>  这使得能对分组进行嵌套，为数据人族提供更细致的控制</li>
<li>如果在<code>GROUP BY</code>子句中嵌套了分组，数据将在最后规定的分组上进行汇总<br>  也就是说，在建立分组时，指定的所有列都一起计算<br>  (所有不能从个别的列取回数据)</li>
<li><code>GROUP BY</code>子句中列出的每个列都必须是检索列或有效的表达式(但不能是聚集函数)<br>  如果在SELECT中使用表达式，则必须在<code>GROUP BY</code>子句中指定相同的表达式<br>  不能使用别名</li>
<li>除聚集计算语句外，SELECT语句中的每个列都必须在<code>GROUP BY</code>子句中给出</li>
<li>如果分组列中具有NULL值，则NULL将作为一个分组返回<br>  如果列中有多行NULL值，它们将分为一组</li>
<li><code>GROUP BY</code>子句必须出现在WHERE子句之后，<code>ORDER BY</code>子句之前</li>
</ul>
<p><strong>使用ROLLUP</strong>：使用<code>WITH ROLLUP</code>关键字，可以得到每个分组以及每个分组汇总级别(针对每个分组)的值<br>如下所示：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_id, COUNT(*) AS num_prods</span><br><span class="line">FROM products</span><br><span class="line">GROUP BY vend_id WITH ROLLUP;</span><br></pre></td></tr></table></figure></div>

<h2 id="过滤分组"><a href="#过滤分组" class="headerlink" title="过滤分组"></a>过滤分组</h2><p>除了能用<code>GROUP BY</code>分组数据外，MySQL还允许过滤分组<br>    规定包括哪些分组，排除哪些分组</p>
<p>与WHERE子句不同，WHERE过滤指定的是行而不是分组<br>事实上，WHERE没有分组的概念</p>
<p>MySQL为此目的提供了另外的子句：<code>HAVING</code>子句<br><code>HACING</code>非常类似于WHERE<br>    唯一的差别是<code>WHERE</code>过滤行，而<code>HACING</code>过滤分组</p>
<p><strong><code>HAVING</code>支持所有<code>WHERE</code>操作符</strong>：<br>    前面所述的WHERE子句的条件(包括通配符条件和带多个操作符的子句)<br>    所有的有关WHERE的计数和选项都适用于<code>HAVING</code><br>    它们的句法是相同的，只是关键字有差别</p>
<p>怎么过滤分组：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_id, COUNT(*) AS orders</span><br><span class="line">FROM order</span><br><span class="line">GROUP BY cust_id</span><br><span class="line">HAVING COUNT(*) &gt;= 2;</span><br></pre></td></tr></table></figure></div>
<pre><code>HAVING子句，过滤`COUNT(*)` &gt;= 2的那些分组
</code></pre>
<p>这里WHERE子句不起作用，因为过滤是基于分组聚集值而不是特定行值的</p>
<p><strong>HAVING和WHERE的差别</strong>：另一种理解方法：<br>    WHERE在数据分组前进行过滤<br>    HAVING在数据分组后进行过滤<br>这是一个重要的区别，WHERE排除的行不包括在分组中<br>这可能会改变计算值，从而影响HAVING子句中基于这些值过滤掉的分组</p>
<p>有时，一条语句中需要同时使用HWERE和HAVING子句<br>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_id, COUNT(*) AS num_prods</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_price &gt;= 10</span><br><span class="line">GROUP BY vend_id</span><br><span class="line">HAVING COUNT(*) &gt;= 2;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>WHERE子句过滤所有prod_price至少为10的行</li>
<li>然后按vend_id分组数据</li>
<li>HAVING子句过滤计数为2或2以上的分组</li>
</ul>
<h2 id="分组和排序"><a href="#分组和排序" class="headerlink" title="分组和排序"></a>分组和排序</h2><p>虽然<code>GROUP BY</code>和<code>ORDER BY</code>经常完成相同的工作，但它们是非常不同的<br>下表汇总了它们之间的差别：<br>表 <code>ORDER BY</code>与<code>GROUP BY</code></p>
<table>
<thead>
<tr>
<th>ORDER BY</th>
<th>GROUP BY</th>
</tr>
</thead>
<tbody><tr>
<td>排序产生的输出</td>
<td>分组行。但输出可能不是分组的顺序</td>
</tr>
<tr>
<td>任意列都可以使用（甚至非选择的列也可以使用）</td>
<td>只可能使用选择列或表达式列，而且必须使用每个选择列表达式</td>
</tr>
<tr>
<td>不一定需要</td>
<td>如果与聚集函数一起使用列（或表达式），则必须使用</td>
</tr>
</tbody></table>
<p><code>GROUP BY</code>分组的数据确实是以分组顺序输出的<br>    但不总是这样，这并不是SQL规范所要求的<br>用户也可能会要求以不同于分组的顺序排序<br>仅因为某种反思分组(获得特定的分组聚集值)，并不表示需要以相同的方式排序输出<br>    应提供明确的<code>ORDER BY</code>子句，即使效果等同于<code>GROUP BY</code>子句也是如此</p>
<p>**不要忘记<code>ORDER BY</code>**：一般在使用<code>GROUP BY</code>子句时，应该也给出<code>ORDER BY</code>子句<br>    这是保证数据正确排序的唯一方法<br>    千万不要仅依赖<code>GROUP BY</code>排序数据</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT order_num, SUM(quantity*item_price) AS ordertotal)</span><br><span class="line">FROM orderitems</span><br><span class="line">GROUP BY order_NUM</span><br><span class="line">HAVING SUM(quantity*item_price) &gt;= 50</span><br><span class="line">ORDER BY ordertotal;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>GROUP BY</code>子句用来按照order_num列分组数据<br>  以便<code>SUM(*)</code>函数能够返回总计</li>
<li>HAVING子句过滤数据，使得只返回总计订单价格大于等于50的订单</li>
<li>最后，用<code>ORDER BY</code>子句排序输出</li>
</ul>
<h2 id="SELECT子句顺序"><a href="#SELECT子句顺序" class="headerlink" title="SELECT子句顺序"></a>SELECT子句顺序</h2><p>回顾SELECT语句中子句的顺序<br>下表以在SELECT语句中使用时必须遵守的次序，列出迄今为止提到过的子句：<br>表 SELECT子句以及顺序</p>
<table>
<thead>
<tr>
<th>子句</th>
<th>说明</th>
<th>是否必须使用</th>
</tr>
</thead>
<tbody><tr>
<td>SELECT</td>
<td>要返回的列或表达式</td>
<td>是</td>
</tr>
<tr>
<td>FROM</td>
<td>从中检索数据的表</td>
<td>仅在从表选择数据时使用</td>
</tr>
<tr>
<td>WHERE</td>
<td>行级过滤</td>
<td>否</td>
</tr>
<tr>
<td>GROUP BY</td>
<td>分组说明</td>
<td>仅在按组计算聚集时使用</td>
</tr>
<tr>
<td>HAVING</td>
<td>组级过滤</td>
<td>否</td>
</tr>
<tr>
<td>ORDER BY</td>
<td>输出排序顺序</td>
<td>否</td>
</tr>
<tr>
<td>LIMIT</td>
<td>要检索的行数</td>
<td>否</td>
</tr>
</tbody></table>
<hr>
<h1 id="使用子查询"><a href="#使用子查询" class="headerlink" title="使用子查询"></a>使用子查询</h1><p>什么是子查询，如何使用子查询</p>
<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p><strong>版本要求</strong>：MySQL 4.1引入对子查询的支持</p>
<p>SELECT语句是SQL的查询，迄今为止的所有SELECT都是简单查询</p>
<p>​	即：从单个数据库表中检索数据的单条语句</p>
<p><strong>查询</strong>：任何SQL语句都是查询，但此术语一般指SELECT语句</p>
<p>SQL允许创建子查询，即嵌套在其他查询中的查询</p>
<h2 id="利用子查询进行过滤"><a href="#利用子查询进行过滤" class="headerlink" title="利用子查询进行过滤"></a>利用子查询进行过滤</h2><p>例：查询出订购物品TNT2的所有客户</p>
<ul>
<li>检索包含物品TNT2的所有订单的编号</li>
<li>检索具有前一步骤列出的订单编号的所有客户的ID</li>
<li>检索前一步骤返回的所有客户ID的客户信息</li>
</ul>
<p>上述每个步骤都可以单独作为一个查询来执行</p>
<p>可以把一条SELECT语句返回的结果用于另一条SELECT语句的WHERE子句</p>
<p>也可以使用子查询来把2个查询组合成一条语句</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_id</span><br><span class="line">FROM orders</span><br><span class="line">WHERE order_num IN (SELECT order_num</span><br><span class="line">					FROM orderitems</span><br><span class="line">					WHERE prod_id = &#x27;TNT2&#x27;);</span><br></pre></td></tr></table></figure></div>

<p>​	在SELECT语句中，子查询总是从内向外处理</p>
<p>内部的查询结果以IN操作符要求的逗号分隔的格式传递给外部查询的WHERE子句</p>
<p>外部查询变成：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_id FROM orders WHERE order_num IN (子查询第一个结果, 子查询第二个结果, ...)</span><br></pre></td></tr></table></figure></div>



<p><strong>格式化SQL</strong>：包含子查询的SELECT语句难以阅读和调试</p>
<p>​	将子查询分解为多行并适当的进行缩进，能极大的简化子查询的使用</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name, cust_contact</span><br><span class="line">FROM customer</span><br><span class="line">WHERE cust_id IN (SELECT cust_id</span><br><span class="line">				  FROM orders</span><br><span class="line">				  WHERE order_num IN (SELECT order_num</span><br><span class="line">				  					  FROM orderitems</span><br><span class="line">				  					  WHERE prod_id = &#x27;TNT2&#x27;));</span><br></pre></td></tr></table></figure></div>



<p>可见，在WHERE子句中使用子查询能够编写出功能很强并很灵活的SQL语句</p>
<p>对于能嵌套的子查询数目没有限制，不过在实际使用时由于性能的限制，不能嵌套太多的子查询</p>
<p><strong>列必须匹配</strong>：在WHERE子句中使用子查询，应该保证SELECT语句具有与WHERE子句中相同数目的列</p>
<p>​	通常，子查询将返回列兵与单个列匹配</p>
<p>​	但如果需要也可以使用多个列</p>
<p>虽然子查询一般与IN操作符结合使用，但也可以用于测试等于(&#x3D;)、不等于(&lt;&gt;)等</p>
<p><strong>子查询和性能</strong>：使用子查询并不总是执行这种类型(最初的例子)的数据检索的最有效的方法</p>
<h2 id="作为计算字段使用子查询"><a href="#作为计算字段使用子查询" class="headerlink" title="作为计算字段使用子查询"></a>作为计算字段使用子查询</h2><p>使用子查询的另一种方法是创建计算字段</p>
<p>例：</p>
<ul>
<li>从customers表中检索客户列表</li>
<li>对检索出的每个客户，统计其在order表中的订单数目</li>
</ul>
<p>可使用<code>SELECT COUNT(*)</code>对表中行进行计数</p>
<p>并通过提供一条WHERE子句来过滤某个特定的客户ID，可仅对该客户的订单进行计数</p>
<p>例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*) AS orders</span><br><span class="line">FROM orders</span><br><span class="line">WHERE cust_id = 10001;</span><br></pre></td></tr></table></figure></div>



<p>为对每个客户执行<code>COUNT(*)</code>计算，应该将<code>COUNT(*)</code>作为一个子查询</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name,</span><br><span class="line">	   cust_state,</span><br><span class="line">	   (SELECT COUNT(*)</span><br><span class="line">	   	FROM orders</span><br><span class="line">	   	WHERE orders.cust_id = customers.cust_id) AS orders</span><br><span class="line">FROM customers</span><br><span class="line">ORDER BY cust_name;</span><br></pre></td></tr></table></figure></div>



<p><strong>相关子查询</strong>：涉及外部查询的子查询</p>
<p>任何时候只要列名可能有多义性，就必须使用这种语法(表名和列名由一个句点分隔)</p>
<p>虽然子查询在构造这种SELECT语句时极有用，但必须注意限制有歧义性的列名</p>
<p><strong>不止一种解决方案</strong>：虽然能用，但不是解决这种数据检索的最有效的方法</p>
<p><strong>逐渐增加子查询来建立查询</strong>：用子查询测试和调试查询很有技巧性，特别是在语句的复杂性不断增加的情况下</p>
<p>用子查询建立(和车市)查询的最可靠的方法是逐渐进行</p>
<p>​	这与MySQL处理它们的方法非常相同</p>
<ul>
<li><p>首先建立和测试最内层的查询</p>
</li>
<li><p>然后用硬编码数据建立和测试外层查询</p>
</li>
<li><p>并且仅在确认它正常后再嵌入子查询</p>
</li>
</ul>
<p>这时再测试它</p>
<p>对于要增加的每个查询，重复这些步骤</p>
<p>这样做仅给构造查询增加了一点点时间，但节省了以后找出查询为什么不正常的大量时间，并极大的提高了查询一开始就正常工作的可能性</p>
<hr>
<h1 id="联结表"><a href="#联结表" class="headerlink" title="联结表"></a>联结表</h1><p>什么是联结，为什么用联结，如何使用联结</p>
<h2 id="联结"><a href="#联结" class="headerlink" title="联结"></a>联结</h2><p>SQL最强大的功能之一：在数据检索查询的执行中联结表</p>
<p>联结表是利用SQL的SELECT能执行的最重要的操作</p>
<p>以下介绍关系数据库设计的一些基础知识</p>
<h3 id="关系表"><a href="#关系表" class="headerlink" title="关系表"></a>关系表</h3><p>相同数据出现多次绝不是一件好事，这是关系数据库设计的基础</p>
<p>关系表的设计：要保证把信息分解成多个表，一类数据一个表</p>
<p>各表通过某些常用的值(关系)互相关联</p>
<p><strong>主键</strong>：唯一标识每一行</p>
<p><strong>外键</strong>：某个表中的一列，包含另一个表的主键值，定义了两个表之间的关系</p>
<p>好处：</p>
<ul>
<li>信息不重复，不浪费时间和空间</li>
<li>如果信息变动，可以只更新少量表中的单个记录，相关表中的数据不用改动</li>
<li>由于数据无重复，显然数据是一致的，处理数据更简单</li>
</ul>
<p>关系数据可以有效的存储和方便的处理</p>
<p>​	因此，关系数据库的可伸缩性远比非关系数据库要好</p>
<p><strong>可伸缩性</strong>：能够适应不断增加的工作量而不失败</p>
<p>​	设计良好的数据库或应用程序称之为可伸缩性好</p>
<h3 id="为什么要使用联结"><a href="#为什么要使用联结" class="headerlink" title="为什么要使用联结"></a>为什么要使用联结</h3><p>分解数据为多个表能更有效的存储，更方便的处理，且具有更大的可伸缩性</p>
<p>好处是有代价的</p>
<p>如果数据存储在多个表中，如何用单条SELECT语句检索出数据？</p>
<p>​	使用联结，一种机制，用来在一条SELECT语句中关联表，因此称为联结</p>
<p>使用特殊的语法，可联结多个表安徽一组输出，联结在运行时关联表中正确的行</p>
<p><strong>维护引用完整性</strong>：联结在实际的数据库表中不存在</p>
<p>联结由MySQL根据需要建立，存在于查询的执行当中</p>
<p>在使用关系表时，仅在关系列中插入合法的数据非常重要</p>
<p>可指示MySQL只允许在对应列中出现合法值</p>
<p>这就是维护引用完整性，是通过在表的定义中指定主键和外键来实现的</p>
<h2 id="创建联结"><a href="#创建联结" class="headerlink" title="创建联结"></a>创建联结</h2><p>规定要联结的所有表以及它们如何关联即可</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_name, prod_name, prod_price</span><br><span class="line">FROM vendors, products</span><br><span class="line">WHERE vendors.vend_id = products.vend_id</span><br><span class="line">ORDER BY vend_name, prod_name;</span><br></pre></td></tr></table></figure></div>

<p>​	此FRO子句列出了两个表，是联结的两个表的名字</p>
<p>这两个表用WHERE子句正确连接</p>
<p><strong>完全限定列名</strong>：在引用的列可能出现二义性时，必须使用完全限定列名</p>
<h3 id="WHERE子句的重要性"><a href="#WHERE子句的重要性" class="headerlink" title="WHERE子句的重要性"></a>WHERE子句的重要性</h3><p>在一条SELECT语句中联结几个表时，相应的关系是在运行中构造的</p>
<p>在数据库表的定义中不存在能指示MySQL如何对表进行联结的东西</p>
<p>实际上是将第一个表的每一行与第二个表中的每一行匹配</p>
<p>WHERE子句作为过滤条件，值包含哪些联结条件的行</p>
<p><strong>笛卡儿积</strong>：由没有联结条件的表关系返回的结果为笛卡儿积</p>
<p>检索出的行的数目将是第一个表中的行数乘以第二个表中的行数</p>
<p><strong>不要忘了WHERE子句</strong>：应该保证所有连接都有WHERE子句，否则MySQL将返回比想要的数据多得多的数据</p>
<p>同理，应该保证WHERE子句的正确性</p>
<p>​	不正确的过滤条件将导致MySQL返回不正确的数据</p>
<p><strong>叉联结</strong>：有时会听到返回称为叉联结的笛卡儿积的联结类型</p>
<h3 id="内部联结"><a href="#内部联结" class="headerlink" title="内部联结"></a>内部联结</h3><p>目前用的都为等值联结，基于两个表之间的相等性测试</p>
<p>这种联结也称为<strong>内部联结</strong></p>
<p>​	对于这种联结可以使用别的语法来明确指定联结的类型：</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_name, prod_name, prod_price</span><br><span class="line">FROM vendors INNER JOIN products</span><br><span class="line"> ON vendors.vend_id = products.vend_id;</span><br></pre></td></tr></table></figure></div>

<p>​	FROM子句不同</p>
<p>这里两表之间的关系是FROM子句的组成部分，以<code>INNER JOIN</code>指定</p>
<p>在使用这种语法时，联结条件用特定的ON子句，而不是WHERE子句给出</p>
<p>​	传递给ON的实际条件与传递给WHERE的相同</p>
<p><strong>使用哪种语法</strong>：ANSI SQL规范首选INNER JOIN语法</p>
<p>使用明确的联结语法能够确保不会忘记联结条件，有时也能影响性能</p>
<h3 id="联结多个表"><a href="#联结多个表" class="headerlink" title="联结多个表"></a>联结多个表</h3><p>SQL对一条SELECT语句中可以联结的表的数目没有限制</p>
<p>创建联结的基本规则也相同</p>
<p>先列出所有表，然后定义表之间的关系：</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name, vend_name, prod_price, quantity</span><br><span class="line">FROM orderitems, products, vendors</span><br><span class="line">WHERE products.vend_id = vendors.vend_id</span><br><span class="line">	AND orderitems.prod_id = products.prod_id</span><br><span class="line">	AND order_num = 20005;</span><br></pre></td></tr></table></figure></div>

<p>​	FROM子句列出了3个表</p>
<p>​	WHERE子句定义了这两个联结条件</p>
<p>​	第三个联结条件用来过滤出订单20005中的物品</p>
<p><strong>性能考虑</strong>：MySQL在运行时关联指定的每个表以处理连接</p>
<p>这种处理可能是非常耗费资源的，应该仔细，不要联结不必要的表</p>
<p>​	联结的表越多，性能下降的越厉害</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name, cust_contact</span><br><span class="line">FROM customers</span><br><span class="line">WHERE cust_id IN (SELECT cust_id</span><br><span class="line">				  FROM orders</span><br><span class="line">				  WHERE order_num IN (SELECT order_num</span><br><span class="line">				  					  FROM orderitems</span><br><span class="line">				  					  WHERE prod_id = &#x27;TNT2&#x27;));</span><br></pre></td></tr></table></figure></div>



<p>前面所说，子查询并不总是执行复杂SELECT操作的最有效的方法，下面是使用联结的相同查询：</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name, cust_contact</span><br><span class="line">FROM customers, orders, orderitems</span><br><span class="line">WHERE customers.cust_id = orders.cust_id</span><br><span class="line">	AND prderitems.order_num = orders.order_num</span><br><span class="line">	AND prod_id = &#x27;TNT2&#x27;;</span><br></pre></td></tr></table></figure></div>

<p>​	没有使用嵌套子查询，而是使用了两个联结</p>
<p><strong>多做实验</strong>：为执行任一给定的SQL操作，一般存在不足一种方法</p>
<p>很少有绝对正确或错误的方法，性能可能会受操作类型、表中数据量、是否存在索引或键、以及其他一些条件影响</p>
<p>因此，有必要对不同的选择机制进行实验，以找出最适合具体情况的方法</p>
<hr>
<h1 id="创建高级联结"><a href="#创建高级联结" class="headerlink" title="创建高级联结"></a>创建高级联结</h1><p>另外一些联结类型，如何对被联结的表使用表别名和聚集函数</p>
<h2 id="使用表别名"><a href="#使用表别名" class="headerlink" title="使用表别名"></a>使用表别名</h2><p>给列起别名的语法如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT Concat(RTrim(vend_name), &#x27; (&#x27;, RTrim(vend_country), &#x27;)&#x27;) AS vend_title</span><br><span class="line">FROM vendors</span><br><span class="line">ORDER BY vend_name;</span><br></pre></td></tr></table></figure></div>

<p>别名除了用于列名和计算字段外，SQL还允许给表名起别名</p>
<ul>
<li>缩短SQL语句</li>
<li>允许在单条SELECT语句中多次使用相同的表</li>
</ul>
<p>表别名不仅能用于WHERE子句，还能用于SELECT的列表、ORDER BY子句，以及语句的其他部分</p>
<p>应注意，别名只在查询执行中使用</p>
<p>与列别名不一样，表别名不返回到客户机</p>
<h2 id="使用不同类型的联结"><a href="#使用不同类型的联结" class="headerlink" title="使用不同类型的联结"></a>使用不同类型的联结</h2><p>至今使用的称为内部联结或等值联结的简单链接</p>
<p>其他三种链接：自联结、自然联结、外部联结</p>
<h3 id="自联结"><a href="#自联结" class="headerlink" title="自联结"></a>自联结</h3><p>使用表别名的主要原因之一：能在单条SELECT语句中不止一次引用相同的表</p>
<p>使用子查询：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_id, prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_id = (SELECT vend_id</span><br><span class="line">				 FROM products</span><br><span class="line">				 WHERE prod_id = &#x27;DTNTR&#x27;);</span><br></pre></td></tr></table></figure></div>



<p>使用联结的相同查询：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT p1.prod_id, p1.prod_name</span><br><span class="line">FROM products AS p1, products AS p2</span><br><span class="line">WHERE p1.vend_id = p2.vend_id</span><br><span class="line">	AND p2.prod_id = &#x27;DTNTR&#x27;;</span><br></pre></td></tr></table></figure></div>

<p>为避免二义性，使用了表别名</p>
<p><strong>使用自联结而不用子查询</strong>：自联结通常作为外部语句用来替代从相同表中检索数据时使用的子查询语句</p>
<p>虽然最终结果相同，但优势处理联结远比处理子查询快得多</p>
<p>应该试一下两种方法，以确定哪一种的性能更好</p>
<h3 id="自然联结"><a href="#自然联结" class="headerlink" title="自然联结"></a>自然联结</h3><p>无论何时对表进行联结，应该有至少一个列出现在不止一个表中</p>
<p>标准的联结(内部联结)返回所有数据，甚至相同的列多次出现</p>
<p>自然联结排除多次出现，使每个<strong>列</strong>只返回一次</p>
<p>系统不完成这项工作，需要自己完成</p>
<p>自然联结只能选择那些唯一的列，这一般是通过对表使用通配符(<code>SELECT *</code>)，对所有其他表的列使用明确的子集来完成的</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT c.*, o.order_num, order_date,</span><br><span class="line">	oi.prod_id, oi.quantity, OI.item_price</span><br><span class="line">FROM customers AS c, orders AS o, orderitems AS oi</span><br><span class="line">WHERE c.cust_id = o.cust_id</span><br><span class="line">	ANS oi.order_num = o.order_num</span><br><span class="line">	AND prod_id = &#x27;FB&#x27;;</span><br></pre></td></tr></table></figure></div>

<p>实际上，迄今为止建立的每个内部联结都是自然联结，很可能永远都不会用到不是自然联结的内部联结</p>
<h3 id="外部联结"><a href="#外部联结" class="headerlink" title="外部联结"></a>外部联结</h3><p>联结包含了那些在相关表中没有关联行的行，这种类型的外联结称为<strong>外部联结</strong></p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT customers.cust_id, orders.order_num</span><br><span class="line">FROM customer LEFT OUTER JOIN orders</span><br><span class="line">	ON customers.cust_id = orders.cust_id;</span><br></pre></td></tr></table></figure></div>

<p>​	使用了关键字<code>OUTER JOIN</code>来指定联结的类型(而不是在WHERE子句中指定)</p>
<p>与内部联结不同的是，外部联结还包括没有关联的行</p>
<p>在使用<code>OUTER JOIN</code>语法时，必须使用RIGHT或LEFT关键字指定包括其所有行的表</p>
<p><strong>没有<code>*=</code>操作符</strong>：MySQL不支持简化字符<code>*=</code>和<code>=*</code>的使用，这两种操作符在其他DBMS中是很流行的</p>
<p><strong>外部联结的类型</strong>：存在两种基本的外部联结形式：左外部联结和右外部联结</p>
<p>​	唯一差别：所关联的表的顺序不同</p>
<p>左外部联结可通过颠倒<code>FROM</code>或<code>WHERE</code>子句中表的顺序转换为右外联结</p>
<p>两种类型的外部联结可互换使用</p>
<h2 id="使用带聚集函数的联结"><a href="#使用带聚集函数的联结" class="headerlink" title="使用带聚集函数的联结"></a>使用带聚集函数的联结</h2><p>聚集函数可以与联结一起使用</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT customers.cust_name,</span><br><span class="line">	   customers.cust_id,</span><br><span class="line">	   COUNT(orders.order_num) AS num_ord</span><br><span class="line">FROM customers INNER JOIN orders</span><br><span class="line"> ON customers.cust_id = orders.cust_id</span><br><span class="line">GROUP BY customers.cust_id;</span><br></pre></td></tr></table></figure></div>



<h2 id="使用联结和联结条件"><a href="#使用联结和联结条件" class="headerlink" title="使用联结和联结条件"></a>使用联结和联结条件</h2><p>关于联结及其使用的一些要点：</p>
<ul>
<li>注意所使用的联结类型</li>
</ul>
<p>​		一般使用内部联结，但使用外部联结也是有效的</p>
<ul>
<li>保证使用正确的链接条件，否则将返回不正确的数据</li>
<li>应该总是提供联结条件，否则会得出笛卡儿积</li>
<li>在一个联结中可以包含多个表，甚至对于每个链接可以采用不同的链接类型</li>
</ul>
<p>​		合法，且一般很有用，但应该在一起测试它们前，分别测试每个联结，使得故障排除更为简单</p>
<hr>
<h1 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h1><p>利用UNION操作符将多条SELECT语句组合成一个结果集</p>
<h2 id="组合查询-1"><a href="#组合查询-1" class="headerlink" title="组合查询"></a>组合查询</h2><p>MySQL允许执行多个查询(多条SELECT语句)，并将结果作为单个查询结果集返回</p>
<p>这些组合查询通常被称为<strong>并</strong>或<strong>复合查询</strong></p>
<p>两种基本情况，需要使用组合查询：</p>
<ul>
<li>在单个查询中重不同的表返回类似结构的数据</li>
<li>对单个表执行多个查询，按单个查询返回数据</li>
</ul>
<p><strong>组合查询和多个WHERE条件</strong>：任何具有多个WHERE子句的SELECT语句都可以作为一个组合查询给出</p>
<p>两种技术在不同查询中性能不同，应该测试一下，以确定对特定的查询哪一种性能更好</p>
<h2 id="创建组合查询"><a href="#创建组合查询" class="headerlink" title="创建组合查询"></a>创建组合查询</h2><p>可用UNION操作符来组合数条SQL查询</p>
<p>可给出多条SELECT语句，将它们的结果组合成单个结果集</p>
<h3 id="使用UNION"><a href="#使用UNION" class="headerlink" title="使用UNION"></a>使用UNION</h3><p>在各条语句之间放上关键字UNION</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_id, prod_id, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_price &lt;= 5</span><br><span class="line">UNION</span><br><span class="line">SELECT vend_id, prod_id, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_id IN (1001, 1002);</span><br></pre></td></tr></table></figure></div>

<p>UNION指示MySQL执行两条SELECT语句，并把输出组合成单个查询结果集</p>
<p>使用多条WHERE子句的相同查询：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_id, prod_id, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_price &lt;= 5</span><br><span class="line">	OR vend_id IN (1001, 1002);</span><br></pre></td></tr></table></figure></div>



<h3 id="UNION规则"><a href="#UNION规则" class="headerlink" title="UNION规则"></a>UNION规则</h3><p><strong>并</strong>是非常容易使用的</p>
<p>有几条规则需要注意：</p>
<ul>
<li>UNION必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔</li>
<li>UNION中的每个查询必须包含相同的列、表达式、聚集函数(不过各列次序不需要相同)</li>
<li>列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含的转换的类型</li>
</ul>
<p>如果遵循这些基本规则或限制，则可以将<strong>并</strong>用于任何数据检索任务</p>
<h3 id="包含或取消重复的行"><a href="#包含或取消重复的行" class="headerlink" title="包含或取消重复的行"></a>包含或取消重复的行</h3><p>UNION从查询结果集中自动去除重复的行</p>
<p>这是UNION的默认行为，如果需要可以改变</p>
<p>如果想返回所有匹配行，可以使用UNION ALL而不是UNION</p>
<p><strong>UNION与WHERE</strong>：UNION几乎总是完成与多个WHERE条件相同的工作</p>
<p>UNION ALL为UNION的一种形式，完成了WHERE子句完成不了的工作</p>
<h3 id="对组合查询结果排序"><a href="#对组合查询结果排序" class="headerlink" title="对组合查询结果排序"></a>对组合查询结果排序</h3><p>在用UNION组合查询时，只能使用一条ORDER BY子句</p>
<p>必须出现在最后一条SELECT语句之后</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_id, prod_id, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_price &lt;= 5</span><br><span class="line">UNION</span><br><span class="line">SELECT vend_id, prod_id, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_id IN (1001, 1002)</span><br><span class="line">ORDER BY vend_id, prod_price;</span><br></pre></td></tr></table></figure></div>



<p><strong>组合不同的表</strong>：使用UNION的组合查询可以应用于不同的表</p>
<hr>
<h1 id="全文本搜索"><a href="#全文本搜索" class="headerlink" title="全文本搜索"></a>全文本搜索</h1><h2 id="理解全文本搜索"><a href="#理解全文本搜索" class="headerlink" title="理解全文本搜索"></a>理解全文本搜索</h2><p><strong>并非所有引擎都支持全文本搜索</strong>：MySQL支持几种基本的数据库引擎，最常用的引擎为MyISAM和InnoDB</p>
<p>​	前者支持全文本搜索，如果应用中需要全文本搜索功能，应该记住这点</p>
<p>LINK关键字利用通配操作符匹配文本</p>
<p>​	使用LIKE能查找包含特殊值或部分值的行(不管这些值位于列内什么位置)</p>
<p>​	使用正则表达式可以编写查找所需行的非常复杂的匹配模式</p>
<p>虽然这些搜索机制非常有用，但存在几个重要限制：</p>
<ul>
<li><p>性能：</p>
<p>​	通配符和正则表达式匹配通常要求MySQL尝试匹配表中所有行(且这些搜索极少使用表索引)</p>
<p>​	由于被搜索行书不断增加，这些搜索可能非常耗时</p>
</li>
<li><p>明确控制：</p>
</li>
</ul>
<p>​			使用通配符和正则表达式匹配，很难明确的控制匹配什么和不匹配什么</p>
<ul>
<li><p>智能化的结果：</p>
<p>​	虽然基于通配符和正则表达式的搜索提供了非常灵活的搜索，但都不能提供一种智能化的选择结果的方法</p>
</li>
</ul>
<p>所有这些限制以及更多限制都可以用全文本搜索来解决</p>
<p>使用全文本搜索时，MySQL不需要分别查看每个行，不需要分别分析和处理每个词</p>
<p>MySQL可以快速有效的决定哪些词匹配、不匹配、频率等</p>
<h2 id="使用全文本搜索"><a href="#使用全文本搜索" class="headerlink" title="使用全文本搜索"></a>使用全文本搜索</h2><p>为了进行全文本搜索，必须索引被搜索的列，且要随着数据的改变不断的重新索引</p>
<p>在对表列进行适当的设计后，MySQL会自动进行所有的索引和重新索引</p>
<p>在索引之后，SELECT可与<code>Match()</code>和<code>Against()</code>一起使用以实际执行搜索</p>
<h3 id="启用全文本搜索支持"><a href="#启用全文本搜索支持" class="headerlink" title="启用全文本搜索支持"></a>启用全文本搜索支持</h3><p>一般在创建表时启用全文本搜索</p>
<p><code>CREATE TABLE</code>语句接受FULLTEXT子句，它给出被索引列的一个逗号分隔的列表</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE productnotes</span><br><span class="line">(</span><br><span class="line">	note_id		int 		NOT NULL AUTO_INCREMENT,</span><br><span class="line">	prod_id		char(10)	NOT NULL,</span><br><span class="line">	note_date	datetime	NOT NULL,</span><br><span class="line">	not_text	text		NULL,</span><br><span class="line">	PRIMARY KEY(note_id),</span><br><span class="line">	FULLTEXT(note_text)</span><br><span class="line">) ENGING = MyISAM;</span><br></pre></td></tr></table></figure></div>

<p>​	MySQL根据子句<code>FULLTEXT(note_text)</code>的指示对它进行索引</p>
<p>这里FULLTEXT索引单个列，如果需要也可以指定多个列</p>
<p>在定义之后，MySQL自动维护该索引</p>
<p>​	在增加、更新、删除行时，索引随之自动更新</p>
<p>可在创建表时指定FULLTEXT，或稍后指定(在这种情况下所有已有数据必须立即索引)</p>
<p><strong>不要在导入数据时使用FULLTEXT</strong>：更新索引要花时间</p>
<p>应该先导入所有数据，然后再修改表，定义FULLTEXT</p>
<p>这样有助于更快的导入数据</p>
<p>(且使用索引数据的总时间小于在导入每行时分别进行索引所需要的总时间)</p>
<h3 id="进行全文本搜索"><a href="#进行全文本搜索" class="headerlink" title="进行全文本搜索"></a>进行全文本搜索</h3><p>在索引之后，使用两个函数<code>Match()</code>和<code>Against()</code>执行全文本搜索</p>
<ul>
<li><code>Match()</code>指定被搜索的列</li>
<li><code>Against()</code>指定要使用的搜索表达式</li>
</ul>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT note_text</span><br><span class="line">FROM productnotes</span><br><span class="line">WHERE Match(note_text) Against(&#x27;rabbit&#x27;);</span><br></pre></td></tr></table></figure></div>



<p><strong>使用完整的Match()说明</strong>：传递给<code>Match()</code>的值必须与<code>FULLTEXT()</code>定义中的相同</p>
<p>​	如果指定多个列，则必须列出它们(且次序正确)</p>
<p><strong>搜索不区分大小写</strong>：除非使用BINARY方式，否则全文本搜索不区分大小写</p>
<p>全文本搜索对结果排序，具有较高等级的行先返回</p>
<p><strong>排序多个搜索项</strong>：如果指定多个搜索项，则包含多数匹配词的那些行将具有比包含较少词(或仅有一个匹配)的那些行高的等级值</p>
<p>全文本搜索提供了简单LIKE搜索不能提供的功能</p>
<p>​	且由于数据是索引的，全文本搜索还相当快</p>
<h3 id="使用查询扩展"><a href="#使用查询扩展" class="headerlink" title="使用查询扩展"></a>使用查询扩展</h3><p>在使用查询扩展时，MySQL对数据和索引进行两遍扫描来完成搜索：</p>
<ul>
<li>首先，进行一个基本的全文本搜索，找出与搜索条件匹配的所有行</li>
<li>其次，MySQL检查这些匹配行并选择所有有用的词</li>
<li>再其次，MySQL再次进行全文本搜索，这次不仅使用原来的条件，而且还使用所有有用的词</li>
</ul>
<p>利用查询扩展，能找出可能相关的结果，即使它们并不精确包含所查找的词</p>
<p><strong>只用于MySQL版本4.1.1或更高级的版本</strong>：查询扩展功能是在MySQL4.1.1中引入的，因此不能用于之前的版本</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT note_text</span><br><span class="line">FROM productnotes</span><br><span class="line">WHERE Match(note_text) Against(&#x27;anvils&#x27; WITH QUERY EXPANSION);</span><br></pre></td></tr></table></figure></div>

<p>查询扩展极大的增加了返回的行数，但也增加了实际并不想要的行的数目</p>
<p><strong>行越多越好</strong>：表中的行越多(这些行中的文本就越多)，使用查询扩展返回的结果越好</p>
<h3 id="布尔文本搜索"><a href="#布尔文本搜索" class="headerlink" title="布尔文本搜索"></a>布尔文本搜索</h3><p>MySQL支持全文本搜索的另外一种形式：布尔方式</p>
<p>可提供如下内容的细节：</p>
<ul>
<li>要匹配的词</li>
<li>要排斥的词(如果某行包含这个词，则不返回该行，即使它包含其他指定的词也是如此)</li>
<li>排列提示(指定某些词比其他词更重要，更重要的词等级更高)</li>
<li>表达式分组</li>
<li>另外一些内容</li>
</ul>
<p><strong>即使没有FULLTEXT索引也可以使用</strong>：布尔方式不同于迄今为止使用的全文本搜索语法的地方在于</p>
<p>​	即使没有定义FULLTEXT索引，也可以使用它</p>
<p>​	但这是一种非常缓慢的操作(其性能将随着数据量的增加而降低)</p>
<p>演示<code>IN BOLLEAN MODE</code>的作用：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT note_text</span><br><span class="line">FROM productnnotes</span><br><span class="line">WHERE Match(note_text) Against(&#x27;heavy&#x27; IN BOOLEAN MODE);</span><br></pre></td></tr></table></figure></div>

<p>为匹配包含heavy但不包含任意以rope开始的词的行，可使用如下查询：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT note_text</span><br><span class="line">FROM productnotes</span><br><span class="line">WHERE Match(note_text) Against(&#x27;heavy -rope*&#x27; IN BOOLEAN MODE);</span><br></pre></td></tr></table></figure></div>

<p><strong>在MySQL 4.x中所需的代码更改</strong>：如果用的MySQL4.x，则上例可能不返回任何行</p>
<p>​	因为<code>*</code>操作符处理中的一个错误</p>
<p>MySQL 4.x中可使用<code>-ropes</code>而不是<code>-rope*</code>(排除ropes而不是排除任何以rope开始的词)</p>
<p>下表列出支持的所有布尔操作符</p>
<p>表 全文本布尔操作符</p>
<table>
<thead>
<tr>
<th align="left">布尔操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>+</code></td>
<td>包含，此必须存在</td>
</tr>
<tr>
<td align="left"><code>-</code></td>
<td>排除，词必须不出现</td>
</tr>
<tr>
<td align="left"><code>&gt;</code></td>
<td>包含，而且增加等级值</td>
</tr>
<tr>
<td align="left"><code>&lt;</code></td>
<td>包含，且减少等级值</td>
</tr>
<tr>
<td align="left"><code>()</code></td>
<td>把词组成子表达式(允许这些字表达式作为一个组被包含、排除、排列等)</td>
</tr>
<tr>
<td align="left"><code>~</code></td>
<td>取消一个词的排序值</td>
</tr>
<tr>
<td align="left"><code>*</code></td>
<td>词尾的通配符</td>
</tr>
<tr>
<td align="left"><code>&quot;&quot;</code></td>
<td>定义一个短语(与单个词的列表不一样，它匹配整个短语以便包含或排除这个短语)</td>
</tr>
</tbody></table>
<p><strong>排列而不排序</strong>：在布尔方式中，不按照等级值降序排序返回的行</p>
<h3 id="全文本搜索的使用说明"><a href="#全文本搜索的使用说明" class="headerlink" title="全文本搜索的使用说明"></a>全文本搜索的使用说明</h3><p>全文本搜索的某些重要的说明：</p>
<ul>
<li>在索引全文本数据时，短词被忽略且从索引中排除<ul>
<li>短词定义为那些具有3个或3个以下字符的词(如果需要，这个数目可以更改)</li>
</ul>
</li>
<li>MySQL带有一个内建的非用词列表，这些此在索引全文本数据时总是被忽略<ul>
<li>如果需要，可以覆盖这个列表</li>
</ul>
</li>
<li>许多词出现的频率很高，搜索它们没有用处(返回太多的结果)<ul>
<li>因此MySQL规定了一条50%规则，如果一个词出现在50%以上的行中，则将它作为一个非用词忽略</li>
<li>50%规则不用于<code>IN BOOLEAN MODE</code></li>
</ul>
</li>
<li>如果表中的行书少于3行，则全文本搜索不返回结果(因为每个词或者不出现，或者至少出现在50%的行中)</li>
<li>忽略词中的单引号<ul>
<li>例如：<code>don&#39;t</code>索引为dont</li>
</ul>
</li>
<li>不具有词分隔符(包括日语和汉语)的语言不能恰当的放回全文本搜索结果</li>
<li>仅在MyISAM数据库引擎中支持全文本搜索</li>
</ul>
<hr>
<h1 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h1><p>如何利用INSERT语句将数据插入表中</p>
<h2 id="数据插入"><a href="#数据插入" class="headerlink" title="数据插入"></a>数据插入</h2><p><strong>INSERT</strong>用来插入(添加)行到数据库表</p>
<p>插入可以用集中方式使用：</p>
<ul>
<li>插入完整的行</li>
<li>插入行的一部分</li>
<li>插入多行</li>
<li>插入某些查询的结果</li>
</ul>
<p><strong>插入及系统安全</strong>：可针对每个表或用户，可利用MySQL的安全机制禁止使用INSERT语句</p>
<h2 id="插入完整的行"><a href="#插入完整的行" class="headerlink" title="插入完整的行"></a>插入完整的行</h2><p>把数据插入表中的最简单的方法：使用基本的INSERT语法</p>
<p>需指定表名和被插入到新行中的新值：</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO Customers</span><br><span class="line">VALUES(NULL,</span><br><span class="line">	&#x27;Pep E. LaPew&#x27;,</span><br><span class="line">	&#x27;100 Main Street&#x27;,</span><br><span class="line">	&#x27;Los Angeles&#x27;,</span><br><span class="line">	&#x27;CA&#x27;,</span><br><span class="line">	&#x27;90046&#x27;,</span><br><span class="line">	&#x27;USA&#x27;,</span><br><span class="line">	NULL,</span><br><span class="line">	NULL);</span><br></pre></td></tr></table></figure></div>

<p><strong>没有输出</strong>：INSERT语句一般不会产生输出</p>
<p>各个列必须以它们在表定义中出现的次序填充</p>
<p>如果不想给出一个值，又不能省略此列，可以指定一个NULL值(被MySQL忽略，MySQL在此处插入下一个可用的值(对于自动增量))</p>
<p>虽然简单，但并不安全，应该尽量避免使用</p>
<p>高度依赖于表中列的定义次序，且还依赖于次序容易获得的信息</p>
<p>编写INSERT语句的更安全(不过更繁琐)的方法如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO customers(cust_name,</span><br><span class="line">	cust_address,</span><br><span class="line">	cust_city,</span><br><span class="line">	cust_state,</span><br><span class="line">	cust_zip,</span><br><span class="line">	cust_country,</span><br><span class="line">	cust_contact,</span><br><span class="line">	cust_email)</span><br><span class="line">VALUES(&#x27;Pep E. LaPew&#x27;,</span><br><span class="line">	&#x27;100 Main Street&#x27;,</span><br><span class="line">	&#x27;Los Angeles&#x27;,</span><br><span class="line">	&#x27;CA&#x27;,</span><br><span class="line">	&#x27;90046&#x27;,</span><br><span class="line">	&#x27;USA&#x27;,</span><br><span class="line">	NULL,</span><br><span class="line">	NULL);</span><br></pre></td></tr></table></figure></div>

<p>在表名后的括号中明确的给出了列名</p>
<p>在插入行时，MySQL将用VALUES列表中的相应值填入列表中的对应项</p>
<p>VALUES必须以其指定的次序匹配指定的列名，不一定按照各个列出现在实际表中的次序</p>
<p>优点：即使表结构改变，此INSERT语句仍然能正确工作</p>
<p><strong>总是使用列的列表</strong>：一般不要使用没有明确给出列的列表的INSERT语句</p>
<p>​	使用列的列表能使SQL代码继续发挥作用，即使表结构发生了变化</p>
<p>使用这种语法还能省略列，值给某些列提供值</p>
<p><strong>省略列</strong>：如果表的定义允许，则可以在INSERT操作中省略某些列</p>
<p>省略的列必须满足以下某个条件：</p>
<ul>
<li>该列定义为允许NULL值(无值或空值)</li>
<li>该表定义中给出默认值<ul>
<li>这表示如果不给出值，将使用默认值</li>
</ul>
</li>
</ul>
<p>如果对表中不允许NULL值且没有默认值的列不给出值，则MySQL将产生一条错误信息，且相应的行插入不成功</p>
<p><strong>提高整体性能</strong>：INSERT操作可能很耗时，且可能降低等待处理的SELECT语句的性能</p>
<p>如果数据检索是最重要的(通常是这样)，则可以通过在INSERT和INTO之间添加关键字<code>LOW_PRIORITY</code>指示MySQL降低INSERT语句的优先级：</p>
<p>​	<code>INSERT LOW_PRIORITY INTO</code></p>
<p>这也适用于UPDATE和DELETE语句</p>
<h2 id="插入多个行"><a href="#插入多个行" class="headerlink" title="插入多个行"></a>插入多个行</h2><p>可以使用多条INSERT语句插入多行，甚至一次提交它们</p>
<p>每条语句用一个分号结束</p>
<p>或者，只要每条INSERT语句中的列名(和次序)相同，可以如下组合各语句：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO customers(cust_name,</span><br><span class="line">	cust_address,</span><br><span class="line">	cust_city,</span><br><span class="line">	cust_state,</span><br><span class="line">	cust_zip,</span><br><span class="line">	cust_country)</span><br><span class="line">VALUES(</span><br><span class="line">	&#x27;Pep E. LaPew&#x27;,</span><br><span class="line">	;100 Main Street&#x27;,</span><br><span class="line">	;Los Angeles&#x27;,</span><br><span class="line">	&#x27;CA&#x27;,</span><br><span class="line">	&#x27;90046&#x27;,</span><br><span class="line">	&#x27;USA&#x27;</span><br><span class="line">	 ),</span><br><span class="line">	 (</span><br><span class="line">	&#x27;M. Martian&#x27;,</span><br><span class="line">	&#x27;42 Galaxy Way&#x27;,</span><br><span class="line">	&#x27;New York&#x27;,</span><br><span class="line">	&#x27;NY&#x27;,</span><br><span class="line">	&#x27;11213&#x27;,</span><br><span class="line">	&#x27;USA&#x27;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<p>其中单条INSERT语句中有多组值，每组值用一对圆括号括起来，用逗号分隔</p>
<p><strong>提高INSERT的性能</strong>：此技术可以提高数据库处理的性能</p>
<p>​	因为MySQL用单条INSERT语句处理多个插入比使用多条INSERT语句快</p>
<h2 id="插入检索出的数据"><a href="#插入检索出的数据" class="headerlink" title="插入检索出的数据"></a>插入检索出的数据</h2><p>ISNERT还存在另一种形式，可以利用它将一条SELECT语句的结果插入表中</p>
<p>这就是<code>INSERT SELECT</code>，由一条INSERT语句和一条SELECT语句组成</p>
<p>注：不应该使用在表中使用过的主键值(如果主键值重复，后续的INSERT操作将会失败)或仅省略这个值让MySQL在导入数的过程中产生新值</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO customers(cust_id.</span><br><span class="line">	cust_name,</span><br><span class="line">	cust_address,</span><br><span class="line">	cust_city,</span><br><span class="line">	cust_state,</span><br><span class="line">	cust_zip,</span><br><span class="line">	cust_country)</span><br><span class="line">SELECT cust_id.</span><br><span class="line">	cust_name,</span><br><span class="line">	cust_address,</span><br><span class="line">	cust_city,</span><br><span class="line">	cust_state,</span><br><span class="line">	cust_zip,</span><br><span class="line">	cust_country</span><br><span class="line">FROM custnew;</span><br></pre></td></tr></table></figure></div>

<p>如果这个表为空，则没有行被插入(也不产生错误，因为操作仍然是合法的)</p>
<p><strong><code>INSERT SELECT</code>中的列名</strong>：为简单起见，使用了相同的列名</p>
<p>实际上，不一定要求列名匹配，MySQL甚至不关心SELECT返回的列名</p>
<p>​	它使用的是列的位置</p>
<p>这对于从使用不同列名的表中导入数据是非常有用的</p>
<p>INSERT SELECT中SELECT语句可包含WHERE子句以过滤插入的数据</p>
<hr>
<h1 id="更新和删除数据"><a href="#更新和删除数据" class="headerlink" title="更新和删除数据"></a>更新和删除数据</h1><p>如何利用UPDATE和DELETE语句进一步操纵表数据</p>
<h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><p>为更新(修改)表中的数据，可使用UPDATE语句</p>
<p>可采用两种方式使用UPDATE：</p>
<ul>
<li>更新表中特定行</li>
<li>更新表中所有行</li>
</ul>
<p><strong>不要省略WHERE子句</strong>：在使用UPDATE时一定要注意，否则就会更新表中所有行</p>
<p><strong>UPDATE与安全</strong>：可以限制和控制UPDATE语句的使用</p>
<p>基本UPDATE语句由3部分组成：</p>
<ul>
<li>要更新的表</li>
<li>列名和它们的新值</li>
<li>确定要更新行的过滤条件</li>
</ul>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE customers</span><br><span class="line">SET cust_emaio = &#x27;elmer@fudd.com&#x27;</span><br><span class="line">WHERE cust_id = 10005;</span><br></pre></td></tr></table></figure></div>

<p>UPDATE语句以WHERE子句结束，它告诉MySQL更新哪一行</p>
<p>没有WHERE子句，MySQL将会更新表中所有行</p>
<p>更新多个列的语法稍有不同：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UPDATE customers</span><br><span class="line">SET cust_name = &#x27;The Fudds&#x27;,</span><br><span class="line">	cust_email = &#x27;elmer@fudd.com&#x27;</span><br><span class="line">WHERE cust_id = 10005;</span><br></pre></td></tr></table></figure></div>

<p>在更新多个列式，只需要使用单个SET命令</p>
<p>每个”列&#x3D;值”对之间用逗号分隔(最后一列之后不用逗号)</p>
<p><strong>在UPDATE语句中使用子查询</strong>：UPDATE语句中可以使用子查询，使得能用SELECT语句检索出的数据更新数据</p>
<p><strong>IGNORE关键字</strong>：如果用UPDATE语句更新多行，并且在更新这些行中的一行或多行时出现一个错误</p>
<p>​	则整个UPDATE操作被取消</p>
<p>为即使是发生错误，也继续更新，可使用IGNORE关键字：</p>
<p>​	<code>UPDATE IGNORE customers...</code></p>
<p>为了删除某个列的值，可设置它为NULL(假如表定义允许NULL值)</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE customers</span><br><span class="line">SET cust_email = NULL</span><br><span class="line">WHERE cust_id = 10005;</span><br></pre></td></tr></table></figure></div>

<p>其中NULL用来去除cust_email列中的值</p>
<h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><p>使用DELETE语句，可用两种方式使用DELETE：</p>
<ul>
<li>从表中删除特定的行</li>
<li>从表中删除所有行</li>
</ul>
<p><strong>不要省略WHERE子句</strong>：在使用DELETE时一定要注意细心，因为稍不注意，就会错误的删除表中所有行</p>
<p><strong>DELETE与安全</strong>：可以限制和控制DELETE语句的使用</p>
<p>DELETE比UPDATE还容易使用：</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM customers</span><br><span class="line">WHERE cust_id = 10006;</span><br></pre></td></tr></table></figure></div>

<p>DELETE不需要列名或通配符</p>
<p>DELETE删除整行而不是删除列</p>
<p>为了删除列，请使用UPDATE语句</p>
<p><strong>删除表的内容而不是表</strong>：DELETE语句从表中删除行，甚至删除表中所有行</p>
<p>​	但是，DELETE不删除表本身</p>
<p><strong>更快的删除</strong>：如果想从表中删除所有行，不要使用DELETE</p>
<p>​	可使用<code>TRUNCATE TABLE</code>语句，完成相同的工作，但速度更快(TRUNCATE实际是删除原来的表并重新创建一个表，而不是逐行删除表中的数据 )</p>
<h2 id="更新和删除的指导原则"><a href="#更新和删除的指导原则" class="headerlink" title="更新和删除的指导原则"></a>更新和删除的指导原则</h2><p>使用UPDATE或DELETE时所遵循的习惯：</p>
<ul>
<li><p>除非确实打算更新和删除每一行，否则绝对不要使用不带WHERE子句的UPDATE或DELETE语句</p>
</li>
<li><p>保证每个表都有主键（如果忘记这个内容，请参阅第15章），尽可能像WHERE子句那样使用它（可以指定各主键、多个值或值的范围）</p>
</li>
<li><p>在对UPDATE或DELETE语句使用WHERE子句前，应该先用SELECT进行测试，保证它过滤的是正确的记录，以防编写的WHERE子句不正确</p>
</li>
<li><p>使用强制实施引用完整性的数据库，这样MySQL将不允许删除具有与其他表相关联的数据的行。</p>
<p><strong>小心使用</strong>：MySQL没有撤销（undo）按钮。应该非常小心地使用UPDATE和DELETE，否则你会发现自己更新或删除了错误的数据</p>
</li>
</ul>
<hr>
<h1 id="创建和操纵表"><a href="#创建和操纵表" class="headerlink" title="创建和操纵表"></a>创建和操纵表</h1><p>表的创建、更改和删除的基本常识</p>
<h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><p>MySQL可以执行数据库和表的所有操作，包括表本身的创建和处理</p>
<p>一般的两种创建表的方法：</p>
<ul>
<li>使用具有交互式创建和管理表的工具</li>
<li>表也可以直接用MySQL语句操纵</li>
</ul>
<p>为使用程序创建表，可使用SQL的<code>CREATE TABLE</code>语句</p>
<p>在使用交互式工具时，实际上使用的是MySQL语句</p>
<h3 id="表创建基础"><a href="#表创建基础" class="headerlink" title="表创建基础"></a>表创建基础</h3><p>利用<code>CREATR TABLE</code>创建表，必须给出下列信息：</p>
<ul>
<li>新表的名字，在关键字<code>CREATE TABLE</code>之后给出</li>
<li>表列的名字和定义，用逗号分隔</li>
</ul>
<p><code>CREATE TABLE</code>语句也可能包括其他关键字或选项，但至少要包括表的名字和列的细节</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE customers</span><br><span class="line">(</span><br><span class="line">	cust_id		 int 	  NOT NULL AUTO_INCREMENT,</span><br><span class="line">	cust_name	 char(50)  NOT NULL ,</span><br><span class="line">	cust_address char(50)	NULL ,</span><br><span class="line">	cust_city	 char(50)   NULL ,</span><br><span class="line">	cust_state	 char(5)	NULL ,</span><br><span class="line">	cust_zip	 char(10)	NULL ,</span><br><span class="line">	cust_country char(50) 	NULL ,</span><br><span class="line">	cust_contact char(50) 	NULL ,</span><br><span class="line">    cust_email 	 char(255)  NULL ,</span><br><span class="line">    PRIMARY KEY (cust_id)</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure></div>

<p>表的主键可以在创建表时用<code>PRIMARY KEY</code>关键字指定</p>
<p><strong>语句格式化</strong>：MySQL语句中忽略空格</p>
<p>​	使用某种缩进格式可以便于阅读和编辑，SQL语句没有规定缩进格式</p>
<p><strong>处理现有的表</strong>：在创建新表时，指定的表名必须不存在，否则将出错</p>
<p>​	如果要防止意外覆盖已有的表，SQL要求先手工删除该表，然后再重建它，而不是简单的用创建表语句覆盖它</p>
<p>​	如果仅想在一个表不存在时创建它，应在表名后给出<code>IF NOT EXISTS</code></p>
<p>​	这样不做检查已有表的模式是否与打算创建的表模式相匹配</p>
<p>​	只查看表名是否存在，且仅在表名不存在时创建它</p>
<h3 id="使用NULL值"><a href="#使用NULL值" class="headerlink" title="使用NULL值"></a>使用NULL值</h3><p>在插入或更新行时，不允许NULL值的列必须有值</p>
<p>每个表列或是<code>NULL</code>列，或是<code>NOT NULL</code>列，这种状态在创建时由表的定义规定</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE orders</span><br><span class="line">(</span><br><span class="line">	order_num	int		 NOT NULL AUTO_INCREMENT.</span><br><span class="line">	order_date	datetime NOT NULL ,</span><br><span class="line">	cust_id		int		 NOT NULL ,</span><br><span class="line">	PRIMARY KEY (order_num)</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure></div>

<p>NULL为默认设置，如果不指定NOT NULL，则认为指定的是NULL</p>
<p><strong>理解NULL</strong>：NULL值与空串不同，空串是有效值</p>
<h3 id="主键再介绍"><a href="#主键再介绍" class="headerlink" title="主键再介绍"></a>主键再介绍</h3><p>主键值必须唯一：表中每行必须具有唯一的主键</p>
<p>如果主键使用多个列，则这些列的组合值必须唯一</p>
<p>创建单个列组成的主键：<code>PRIMARY KEY (vend_id)</code></p>
<p>创建多个列组成的主键：以逗号分隔的列表给出各列表名</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PRIMARY KEY (order_num, order_item)</span><br></pre></td></tr></table></figure></div>

<p>主键可以在创建表时定义，或者在创建表之后定义</p>
<p><strong>主键和NULL值</strong>：主键中只能使用不允许NULL值的列</p>
<p>​	允许NULL值的列不能作为唯一标识</p>
<h3 id="使用AUTO-INCREMENT"><a href="#使用AUTO-INCREMENT" class="headerlink" title="使用AUTO_INCREMENT"></a>使用AUTO_INCREMENT</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cust_id   int   NOT NULL AUTO_INCREMENT</span><br></pre></td></tr></table></figure></div>

<p>告知MySQL，本列每当增加一行时自动增量</p>
<p>每次执行一个INSERT操作时，MySQL自动对该列增量</p>
<p>​	给改列赋予下一个可用的值</p>
<p>这样给每个行分配一个唯一的值，从而可以用作主键值</p>
<p>每个表只允许一个AUTO_INCREMENT列，且它必须被索引(如，通过使它成为主键)</p>
<p><strong>覆盖AUTO_INCREMENT</strong>：可以简单的再INSERT语句中指定一个值，只要它是唯一的(至今尚未使用过)即可</p>
<p>​	该值将被用来替代自动生成的值</p>
<p>后续的增量将开始使用该手工插入的值</p>
<p><strong>确定AUTO_INCREMENT值</strong>：让MySQL生成(通过自动增量)主键的一个缺点是：不知道这些值是什么</p>
<p>可使用<code>laet_insert_id()</code>函数：</p>
<p>​	<code>SELECT last_insert_id()</code></p>
<p>返回最后一个AUTO_INCREMENT值</p>
<h3 id="指定默认值"><a href="#指定默认值" class="headerlink" title="指定默认值"></a>指定默认值</h3><p>如果在插入行时没有给出值，MySQL允许指定此时使用的默认值</p>
<p>默认值用<code>CREATE TABLE</code>语句的列定义中的DEFAULT关键字指定</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE orderitems</span><br><span class="line">(</span><br><span class="line">	quantity  int  NOT NULL DEFAULE 1</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure></div>



<p><strong>不允许函数</strong>：与大多数DBMS不一样，MySQL不允许使用函数作为默认值，它只支持常量</p>
<p><strong>使用默认值而不是NULL值</strong>：许多数据库开发人员使用默认值而不是NULL列</p>
<p>​	特别是对于计算或数据分组的列更是如此</p>
<h3 id="引擎类型"><a href="#引擎类型" class="headerlink" title="引擎类型"></a>引擎类型</h3><p>与其他DBMS一样，MySQL有一个具体管理和处理数据的内部引擎</p>
<p>在使用CREATE TABLE语句时，该引擎具体创建表</p>
<p>而在使用SELECT语句或进行其他数据库处理时，该引擎在内部处理你的请求</p>
<p>多数时候，此引擎都隐藏在DBMS内，不需要过多关注它</p>
<p>MySQL与其他DBMS不同，具有多种引擎</p>
<p>​	它打爆多个引擎，引擎都隐藏在MySQL服务器内，全都能执行<code>CREATE TABLE</code>和<code>SELECT</code>等命令</p>
<p>发行多种引擎的原因：</p>
<p>​	都具有不同的功能和特性，为不同的任务选择正确的引擎能获得良好的功能和灵活性</p>
<p>如果省略<code>ENGINE=</code>语句，则使用默认引擎(很可能是<code>MyISAM</code>)</p>
<p>需要知道的几个引擎：</p>
<ul>
<li>InnoDB是一个可靠的事务处理引擎，，它不支持全文本搜索</li>
<li>MEMORY在功能等同于MyISAM，但由于数据存储在内存(不是磁盘)中，速度很快(特别适合于临时表)</li>
<li>MyISAM是一个性能极高的引擎，它支持全文本搜索，但不支持事务处理</li>
</ul>
<p>引擎类型可以混用</p>
<p><strong>外键不能跨引擎</strong>：混用引擎类型有一个大缺陷，外键(用于强制实施引用完整性)不能跨引擎</p>
<p>​	即，使用一个引擎的表不能引用具有使用不同引擎的表的外键</p>
<h2 id="更新表"><a href="#更新表" class="headerlink" title="更新表"></a>更新表</h2><p>为更新表定义，可使用<code>ALTER TABLE</code>语句</p>
<p>但理想状态下，当表中存储数据以后，该表就不应该再被冰箱</p>
<p>在表的设计过程中需要花费大量时间来考虑，以便后期不对该表进行大的改动</p>
<p>为使用<code>ALTER TABLE</code>更改表结构，必须给出下面的信息：</p>
<ul>
<li>在<code>ALTER TABLE</code>之后给出要更改的表名(该表必须存在，否则将出错)</li>
<li>所做更改的列表</li>
</ul>
<p>例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE vendors</span><br><span class="line">ADD vend_phone CHAR(20);</span><br></pre></td></tr></table></figure></div>

<p>给vendors表增加一个名为vend_phone的列，必须明确其数据类型</p>
<p>删除列：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE Vendors</span><br><span class="line">DROP COLUMN vend_phone;</span><br></pre></td></tr></table></figure></div>



<p><code>ALTER TABLE</code>的一种常见用途是定义外键</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE orderitems</span><br><span class="line">ADD CONSTRAINT fk_orderitems_orders FOREIGN KEY (order_num) REFERENCES orders (order_num);</span><br></pre></td></tr></table></figure></div>



<p>复杂的表结构更改一般需要手动删除过程，涉及以下步骤：</p>
<ul>
<li>用新的列布局创建一个新表</li>
<li>用<code>INSERT SELECT</code>语句从旧表赋值数据到新表<ul>
<li>如果有必要，可使用转换函数和计算字段</li>
</ul>
</li>
<li>检验包含所需数据的新表</li>
<li>重命名旧表(如果确定，可以删除它)</li>
<li>用旧表原来的名字重命名新表</li>
<li>根据需要，重新创建触发器、存储过程、索引、外键</li>
</ul>
<p>**小心使用<code>ALTER TABLE</code>**：使用<code>ALTER TABLE</code>要极为小心，应该在进行改动前做一个完整的备份(模式和数据的备份)</p>
<p>​	数据库表的更改不能撤销，如果增加了不需要的列，可能不能删除它们</p>
<p>​	类似的，如果删除了不该被删除的列，可能会丢失该列中的所有数据</p>
<h2 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h2><p>删除整个表而不是内容，使用<code>DROP TABLE</code>语句：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE customers2;</span><br></pre></td></tr></table></figure></div>

<p>删除customers2表(假设它存在)</p>
<p>删除表没有确认，也不能撤销，执行这条语句将永久删除该表</p>
<h2 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h2><p>使用<code>RENAME TABLE</code>语句可以重命名一个表：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RENAME TABLE customers2 TO customers;</span><br></pre></td></tr></table></figure></div>

<p>仅重命名一个表</p>
<p>可用下面的语句对多个表重命名：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RENAME TABLE backup_customers TO customers,</span><br><span class="line">			 backup_vendors TO vendors,</span><br><span class="line">			 backup_products TO products;</span><br></pre></td></tr></table></figure></div>



<hr>
<h1 id="使用视图"><a href="#使用视图" class="headerlink" title="使用视图"></a>使用视图</h1><p>视图是什么，怎么工作，何时使用</p>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p><strong>需要MySQL 5</strong></p>
<p>视图是虚拟的表</p>
<p>与包含数据的表不一样，视图只包含使用时动态检索数据的查询</p>
<p>视图的作用：将查询包装成一个虚拟表，可轻松用于检索</p>
<p>视图不包含表中应该有的任何列或数据，包含的只是一个SQL查询</p>
<h3 id="为什么使用视图"><a href="#为什么使用视图" class="headerlink" title="为什么使用视图"></a>为什么使用视图</h3><p>视图的一些常见应用：</p>
<ul>
<li>重用SQL语句</li>
<li>简化复杂的SQL操作<ul>
<li>在编写查询后，可以方便的重用它而不必知道它的基本查询细节</li>
</ul>
</li>
<li>使用表的组成部分而不是整个表</li>
<li>保护数据<ul>
<li>可以给用户授予表的特定部分的访问权限而不是整个表的访问权限</li>
</ul>
</li>
<li>更改数据格式和表示<ul>
<li>视图可返回与底层表的表示和格式不同的数据</li>
</ul>
</li>
</ul>
<p>在视图创建后，可以用于表基本相同的方式利用它们</p>
<p>可对视图执行SELECT操作，过滤和排序数据，将试图联结到其他视图或表，甚至能添加和更新数据(存在某些限制)</p>
<p>视图仅仅是用来查看存储在别处的数据的一种设施，本身不包含数据</p>
<p><strong>性能问题</strong>：因为视图不包含数据，所以每次使用视图时都必须处理查询执行时所需的人一个检索</p>
<p>如果用多个联结和过滤创建了复杂的视图或嵌套了视图，可能性能下降的很厉害</p>
<p>​	因此在部署使用了大量视图的应用前，应该进行测试</p>
<h3 id="视图的规则和限制"><a href="#视图的规则和限制" class="headerlink" title="视图的规则和限制"></a>视图的规则和限制</h3><p>关于视图创建和使用的一些最常见的规则和限制：</p>
<ul>
<li>与表一样，视图必须唯一命名(不能给视图取别的视图或表相同的名字)</li>
<li>对于可以创建的视图数目没有限制</li>
<li>为了创建视图，必须具有足够的访问权限<ul>
<li>这些限制通常由数据库管理人员授予</li>
</ul>
</li>
<li>视图可以嵌套<ul>
<li>即可以利用其他视图中检索数据的查询来构造一个视图</li>
</ul>
</li>
<li><code>ORDER BY</code>可以用在视图中<ul>
<li>但如果从该视图检索数据的SELECT中也含有<code>ORDER BY</code>，那么该视图中的<code>ORDER BY</code>将被覆盖</li>
</ul>
</li>
<li>视图不能索引，也不能有关联的触发器或默认值</li>
<li>视图可以和表一起使用<ul>
<li>例如：编写一条联结表和视图的SELECT语句</li>
</ul>
</li>
</ul>
<h2 id="使用视图-1"><a href="#使用视图-1" class="headerlink" title="使用视图"></a>使用视图</h2><p>视图的创建</p>
<ul>
<li>视图用<code>CREATE VIEW</code>来创建</li>
<li>使用<code>SHOW CREATE VIEW viewname;</code>来查看创建视图的语句</li>
<li>用DROP删除视图，可以先用DROP再用CREATE，也可以直接用<code>CREATE OR REPLACE VIEW</code><ul>
<li>如果要更新的视图不存在，则后者会创建一个视图</li>
<li>如过要更新的视图存在，则后者会替换原有视图</li>
</ul>
</li>
</ul>
<h3 id="利用视图简化复杂的联结"><a href="#利用视图简化复杂的联结" class="headerlink" title="利用视图简化复杂的联结"></a>利用视图简化复杂的联结</h3><p>视图最常见的应用之一是：隐藏复杂的SQL，这通常都会涉及联结</p>
<p>例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW procuctcustomers AS</span><br><span class="line">SELECT cust_name, cust_contact, prod_id</span><br><span class="line">FROM customers, order, orderitems</span><br><span class="line">WHERE customers.cust_id = orders.cust_id</span><br><span class="line">	AND orderitems.order_num = orders.order_num;</span><br></pre></td></tr></table></figure></div>

<p>使用时：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name, cust_contact</span><br><span class="line">FROM productcustomers</span><br><span class="line">WHERE prod_id = &#x27;TNT2&#x27;;</span><br></pre></td></tr></table></figure></div>

<p>通过WHERE子句从视图中检索特定数据</p>
<p>可以看出，视图极大的简化了复杂的SQL语句的使用</p>
<p>利用视图，可一次性编写基础的SQL，然后根据需要多次使用</p>
<p><strong>创建可重用的视图</strong>：创建不受特定数据限制的视图是好办法</p>
<p>​	扩展视图的范围不仅使得它能被重用，而且甚至更有用</p>
<p>​	这样做不需要创建和维护多个类似的视图</p>
<h3 id="用视图重新格式化检索出的数据"><a href="#用视图重新格式化检索出的数据" class="headerlink" title="用视图重新格式化检索出的数据"></a>用视图重新格式化检索出的数据</h3><p>视图的另一常见用途：重新格式化检索出的数据</p>
<p>例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT Concat(RTrim(vend_name), &#x27; (&#x27;, RTrim(vend_country), &#x27;)&#x27;) AS vend_title</span><br><span class="line">FROM vendors</span><br><span class="line">ORDER BY vend_name;</span><br></pre></td></tr></table></figure></div>

<p>假如经常需要使用这个格式的结果，不必每次需要时执行联结</p>
<p>​	创建一个视图，每次需要时使用它即可</p>
<p>把此语句转换成视图：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW vendorlocations AS</span><br><span class="line">SELECT Concat(RTrim(vend_name), &#x27; (&#x27;, RTrim(vend_country), &#x27;)&#x27;) AS vend_title</span><br><span class="line">FROM vendors</span><br><span class="line">ORDER BY vend_name;</span><br></pre></td></tr></table></figure></div>



<h3 id="用视图过滤不想要的数据"><a href="#用视图过滤不想要的数据" class="headerlink" title="用视图过滤不想要的数据"></a>用视图过滤不想要的数据</h3><p>视图对于应用普通的WHERE子句也很有用</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW customeremaillist AS</span><br><span class="line">SELECT cust_id, cust_name, cust_email</span><br><span class="line">FROM customers</span><br><span class="line">WHERE cust_email IS NOT NULL;</span><br></pre></td></tr></table></figure></div>



<p><strong>WHERE子句与WHERE子句</strong>：如果从视图检索数据时使用了一条WHERE子句，则两组子句(一组在视图中，另一组是传递给视图的)将自动组合</p>
<h3 id="使用视图与计算字段"><a href="#使用视图与计算字段" class="headerlink" title="使用视图与计算字段"></a>使用视图与计算字段</h3><p>视图对于简化计算字段的使用特别有用</p>
<p>例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW orderitemsexpanded AS</span><br><span class="line">SELECT order_num,</span><br><span class="line">	   prod_id,</span><br><span class="line">	   quantity,</span><br><span class="line">	   item_price,</span><br><span class="line">	   quantity*item_price AS expanded_price</span><br><span class="line">FROM orderitems;</span><br></pre></td></tr></table></figure></div>

<p>使用：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM orderitemsexpanded</span><br><span class="line">WHERE order_num = 20005;</span><br></pre></td></tr></table></figure></div>

<p>可见，视图非常任意创建，而且很好使用。</p>
<p>正确使用，视图可极大的简化复杂的数据处理</p>
<h3 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h3><p>视图能否更新视情况而定</p>
<p>通常视图是可更新的(即对其使用INSERT、UPDATE、DELETE)</p>
<p>​	更新一个视图将更新其基表，如果对视图增加或删除行，实际是对其基表增加或删除行</p>
<p>如果MySQL不能正确的确定被更新的基数据，则不允许更新(包括插入和删除)</p>
<p>实际意味着，如果视图定义中有以下操作，则不能进行视图的更新：</p>
<ul>
<li>分组(使用<code>GROUP BY</code>和<code>HAVING</code>)</li>
<li>联结</li>
<li>子查询</li>
<li>并</li>
<li>聚集函数(<code>Min()</code>、<code>Count()</code>、<code>Sum()</code>等)</li>
<li><code>DISTINCT</code></li>
<li>导出(计算)列</li>
</ul>
<p>似乎是个很严重的限制，但实际上不是，因为视图主要用于数据检索</p>
<p><strong>可能的变动</strong>：上述的限制自MySQL 5以来是正确的，以后就不一定了</p>
<p><strong>将视图用于检索</strong>：一般，应该将视图用于检索(SELECT语句)而不用于更新(INSERT、UPDATE、DELETE)</p>
<hr>
<h1 id="使用存储过程"><a href="#使用存储过程" class="headerlink" title="使用存储过程"></a>使用存储过程</h1><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p><strong>需要MySQL 5</strong></p>
<p>迄今为止，使用的大多数SQL语句都是针对一个或多个表的单条语句</p>
<p>并非所有操作都这么简单，经常会议一个完整的操作需要多条语句才能完成</p>
<p>可以单独编写每条语句，并根据觉过有条件的执行另外的语句</p>
<p>​	在每次需要这个处理时都必须做这些工作</p>
<p>可以创建存储过程：为了以后的使用而保存的一条或多条MySQL语句的集合</p>
<p>​	可将其视为批文件，虽然它们的作用不仅限于批处理</p>
<h2 id="为什么要使用存储过程"><a href="#为什么要使用存储过程" class="headerlink" title="为什么要使用存储过程"></a>为什么要使用存储过程</h2><p>为什么要使用存储过程，一些主要的理由：</p>
<ul>
<li>通过把处理封装在容易使用的单元中，简化复杂的操作</li>
<li>由于不要求反复建立一系列处理步骤，保证了数据的完整性<ul>
<li>如果所有开发人员和应用程序都使用同一(试验和测试)存储过程，则所使用的代码都是相同的</li>
<li>这一点延伸为：防止错误，需要执行的步骤越多，出错的可能性就越大</li>
<li>防止错误保证了数据的一致性</li>
</ul>
</li>
<li>简化对变动的管理<ul>
<li>如果表名、列名、业务逻辑等有变化，只需要更改存储过程的代码</li>
<li>使用它的人员甚至不需要知道这些变化</li>
<li>这一点延伸为：安全性，通过存储过程限制对基础数据的访问 减少了数据讹误(无意识的或别的原因所导致的数据讹误)的机会</li>
</ul>
</li>
<li>提高性能<ul>
<li>因为使用存储过程比使用单独的SQL语句要快</li>
</ul>
</li>
<li>存在一些只能用在单个请求中的MySQL元素和特性，存储过程可以使用它们来编写功能更强更灵活的代码</li>
</ul>
<p>换句话说，使用存储过程有3个主要的好处：简单、安全、高性能</p>
<p>在将SQL代码转换为存储过程前，必须知道它的一些缺陷：</p>
<ul>
<li>一般来说，存储过程的编写比基本SQL语句复杂，编写存储过程需要更高的技能，更丰富的经验</li>
<li>你可能没有创建存储过程的安全访问权限<ul>
<li>许多数据库管理员限制存储过程的创建权限，允许用户使用存储过程，但不允许他们创建存储过程</li>
</ul>
</li>
</ul>
<p>尽管有这些缺陷，存储过程还是非常有用的，并且应该尽可能的使用</p>
<p><strong>不能编写存储过程？仍然可以使用</strong>：MySQL将编写存储过程的安全和访问与执行存储过程的安全和访问区分开来</p>
<p>​	这是好事，即使不能(或不想)编写自己的存储过程也仍然可以在适当的时候执行别的存储过程</p>
<h2 id="使用存储过程-1"><a href="#使用存储过程-1" class="headerlink" title="使用存储过程"></a>使用存储过程</h2><p>MySQL称存储过程的执行为调用因此MySQL执行存储过程的语句为CALL</p>
<p>CALL接受存储过程的名字 以及 需要传递给它的任意参数</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CALL productpricing(@pricelow,</span><br><span class="line">					@pricehigh,</span><br><span class="line">					@priceaverage);</span><br></pre></td></tr></table></figure></div>

<p>其中，执行名为productpricing的存储过程</p>
<p>​	它计算并返回产品的最低、最高和平均价格</p>
<p>存储过程可以显示结果，也可以不显示结果</p>
<h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><p>例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE productpricing()</span><br><span class="line">BEGIN</span><br><span class="line">	SELECT Avg(prod_price) AS priceaverage</span><br><span class="line">	FROM products;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>存储过程名为productpricing</p>
</li>
<li><p>用<code>CREATE PROCEDURE productpricing()</code>语句定义</p>
</li>
<li><p>如果存储过程接受参数，它们将在<code>()</code>中列举出来</p>
</li>
<li><p>此存储过程没有参数，但后跟的<code>()</code>仍然需要<code>BEGIN</code>和<code>END</code>语句用来限定存储过程体</p>
<ul>
<li>过程体本身仅是一个简单的SELECT语句</li>
</ul>
</li>
</ul>
<p>在MySQL处理这段代码时，它创建一个新的存储过程productpricing</p>
<p>没有返回数据，因为这段代码并未调用存储过程，此处只是为以后使用而创建它</p>
<p><strong>mysql命令行客户机的分隔符</strong>：如果使用的是mysql命令行实用程序</p>
<p>​	默认的MySQL语句分隔符为<code>;</code></p>
<p>​	mysql命令行实用程序也使用<code>;</code>作为语句分隔符</p>
<p>​	如果命令行实用程序要接受存储过程自身内的<code>;</code>字符，则它们最终不会成为存储过程的成分，这回使存储过程中的SQL出现语法错误</p>
<p>解决办法是临时更改命令行实用程序的语句分隔符，如下所示：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE productpricing()</span><br><span class="line">BEGIN</span><br><span class="line">	SELECT Avg(prod_price) AS priceaverage</span><br><span class="line">	FROM products;</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>其中<code>DELIMITER //</code>告诉命令行实用程序使用<code>//</code>作为新的语句结束分隔符</p>
</li>
<li><p>可以看到标志存储过程结束的END定义为<code>END //</code>而不是END</p>
</li>
<li><p>这样。存储过程体内的<code>;</code>仍然保持不动，并且正确的传递给数据库引擎</p>
</li>
<li><p>最后，为恢复为原来的语句分隔符，可使用<code>DELIMITER ;</code></p>
</li>
</ul>
<p>除<code>\</code>符号外，任何字符都可以用作语句分隔符</p>
<p>如何使用存储过程：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CALL productpricing();</span><br></pre></td></tr></table></figure></div>

<p>执行刚刚创建的存储过程并显示返回的结果</p>
<p>因为存储过程实际上是一种函数，所以存储过程名称后需要有<code>()</code>符号(即使不传递参数也需要)</p>
<h3 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h3><p>存储过程在创建之后，被保存在服务器上以供使用，直至删除</p>
<p>删除命令从服务器中删除存储过程</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP PROCEDURE productpricing;</span><br></pre></td></tr></table></figure></div>

<p>​	注意没有使用后面的<code>()</code>，只给出存储过程名</p>
<p><strong>仅当存在时删除</strong>：如果指定的过程不存在，则<code>DROP PROCEDURE</code>将产生一个错误</p>
<p>​	当存储过程想删除它是(如果过程不存在也不产生错误)可使用<code>DROP PROCEDURE IF EXISTS</code></p>
<h3 id="使用参数"><a href="#使用参数" class="headerlink" title="使用参数"></a>使用参数</h3><p>一般存储过程并不显示结果，而是把结果返回给指定的变量</p>
<p><strong>变量</strong>：内存中一个特定的位置，用来临时存储数据</p>
<p>以下是prodctpricing的修改版本：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE productpricing(</span><br><span class="line">	OUT pl DECIMAL(8,2),</span><br><span class="line">	OUT ph DECIMAL(8,2),</span><br><span class="line">	OUT pa DECIMAL(8,2)</span><br><span class="line">)</span><br><span class="line">BEGIN</span><br><span class="line">	SELECT Min(prod_price)</span><br><span class="line">	INTO pl</span><br><span class="line">	FROM products;</span><br><span class="line">	SELECT Max(prod_price)</span><br><span class="line">	INTO ph</span><br><span class="line">	FROM products;</span><br><span class="line">	SELECT Avg(prod_price)</span><br><span class="line">	INTO pa</span><br><span class="line">	FROM products;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure></div>

<p>此存储过程接受3个参数，每个参数必须具有指定的类型，这里使用十进制</p>
<p>关键字<code>OUT</code>指出相应的参数用来从存储过程传出一个值(返回给调用者)</p>
<p>MySQL支持<code>IN</code>(传递给存储过程)、<code>OUT</code>(从存储过程传出)、<code>INOUT</code>(对存储传入和传出)类型的参数</p>
<p>存储过程的代码位于<code>BEGIN</code>和<code>END</code>语句内</p>
<p>​	如前所见，是一系列SELECT语句，用来检索值，然后保存到相应的变量(通过指定<code>INTO</code>关键字)</p>
<p><strong>参数的数据类型</strong>：存储过程的参数允许的数据类型与表中使用的数据类型相同</p>
<p>​	注意，记录集不是允许的类型，因此，不能通过一个参数返回多个行和列</p>
<p>​	因此前面的例子使用了3个参数</p>
<p>为调用此修改过的存储过程，必须指定3个变量：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CALL productpricing(@pricelow,</span><br><span class="line">					@pricehigh,</span><br><span class="line">					@priceaverage);</span><br></pre></td></tr></table></figure></div>

<p>由于此存储过程要求3个参数，因此必须正好传递3个参数</p>
<p><strong>变量名</strong>：所有MySQL变量都必须以<code>@</code>开始</p>
<p>调用时，这条语句不显示任何数据，返回以后可以显示(或在其他处理中使用)的变量</p>
<p>为了显示检索出的产品平均价格，可如下进行：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT @priceaverage;</span><br></pre></td></tr></table></figure></div>

<p>为获得3个值，可以使用以下语句：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT @pricehigh, @pricelow, @priceaverage;</span><br></pre></td></tr></table></figure></div>



<p>另一个例子，使用IN和OUT参数：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE ordertotal(</span><br><span class="line">	IN onumber INT,</span><br><span class="line">	OUT total  DECIMAL(8,2)</span><br><span class="line">)</span><br><span class="line">BEGIN</span><br><span class="line">	SELECT Sum(item_price*quantity)</span><br><span class="line">	FROM orderitems</span><br><span class="line">	WHERE order_num = number</span><br><span class="line">	INTO ototal;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure></div>

<p>​	INTO使用ototal存储结果</p>
<p>为调用这个存储过程并获得显示，需先调用存储过程，然后显示变量：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CALL ordertotal(20005, @tota;);</span><br><span class="line">SELECT @total;</span><br></pre></td></tr></table></figure></div>



<h3 id="建立智能存储过程"><a href="#建立智能存储过程" class="headerlink" title="建立智能存储过程"></a>建立智能存储过程</h3><p>迄今为止使用的所有存储过程基本上是封装MySQL简单的SELECT语句</p>
<p>虽然都是有效的存储过程，但能完成的工作直接用被封装的语句就能完成</p>
<p>只有在存储过程内包含业务规则和智能处理时，才更能提心它们的威力</p>
<p>如：</p>
<ul>
<li>获得合计</li>
<li>把营业税有条件的添加到合计</li>
<li>返回合计</li>
</ul>
<p>存储过程的完整工作如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">-- Name: ordertota;</span><br><span class="line">-- Parameters: onumber = order number</span><br><span class="line">--			   taxable = 0 if not taxable, 1 if taxable</span><br><span class="line">--			   ototal = order total variable</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE ordertotal(</span><br><span class="line">	IN onumber INT,</span><br><span class="line">	IN taxable BOOLEAN,</span><br><span class="line">	OUT ototal DECIMAL(8,2)</span><br><span class="line">) COMMEND &#x27;Obtain order total, optionally adding tax&#x27;</span><br><span class="line">BEGIN</span><br><span class="line"></span><br><span class="line">	-- Declare variable for total</span><br><span class="line">	-- 声明变量total</span><br><span class="line">	DECLARE total DECIMAL(8,2);</span><br><span class="line">	-- Declare tax percentage</span><br><span class="line">	-- 定义税金百分比tax</span><br><span class="line">	DECLARE taxrate INT DEFAULT 6;</span><br><span class="line">	</span><br><span class="line">	-- Get the order total</span><br><span class="line">	-- 获取订单总额</span><br><span class="line">	SELECT Sum(item_price*quantity)</span><br><span class="line">	FROM orderitems</span><br><span class="line">	WHERE order_num = onumber</span><br><span class="line">	INTO total;</span><br><span class="line">	</span><br><span class="line">	-- Is this taxable?</span><br><span class="line">	-- 是否需要交税</span><br><span class="line">	IF taxable THEN</span><br><span class="line">		-- 需要交税</span><br><span class="line">		SELECT total+(total/100*taxrate) INTO total;</span><br><span class="line">	END IF;</span><br><span class="line">	</span><br><span class="line">	-- 最后 存储变量</span><br><span class="line">	SELECT total INTO ototal;</span><br><span class="line">	</span><br><span class="line">END;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>首先，增加了注释(前面防止<code>--</code>)</li>
<li>添加了另一个参数taxable<ul>
<li>是一个布尔值(如果要增加稅则为真，否则为假)</li>
</ul>
</li>
<li>在定义存储过程体中，用DECLARE语句定义了两个局部变量<ul>
<li>DECLARE要求指定变量名和数据类型</li>
<li>它也支持可选的默认值(此例中的taxrate的默认值被设置为6%)</li>
</ul>
</li>
<li>SELECT语句已改变，因此结果存储到total(局部变量)而不是ototal</li>
<li>IF语句检查taxable是否为真<ul>
<li>如果为真，则用另一SELECT语句增加营业税到局部变量total</li>
</ul>
</li>
<li>最后，用另一SELECT语句将total(增加或不增加营业税)保存到ototal</li>
</ul>
<p><strong>COMMENT关键字</strong>：本例中的存储过程在<code>CREATE PROCEDURE</code>语句中包含了一个COMMENT值</p>
<p>​	它不是必须的，但如果给出，将在<code>SHOW PROCEDURE STATUS</code>的结果中显式</p>
<p>这显然是个更高级，功能更强的存储过程</p>
<p>为了试验它，使用以下两条语句：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CALL ordertotal(20005, 0, @total);</span><br><span class="line">SELECT @total;</span><br></pre></td></tr></table></figure></div>



<p><strong>IF语句</strong>：此例给出了MySQL的IF语句的基本用法</p>
<p>​	IF语句还支持ELSEIF和ELSE语句(前者还使用THEN子句，后者不能使用)</p>
<h3 id="检查存储过程"><a href="#检查存储过程" class="headerlink" title="检查存储过程"></a>检查存储过程</h3><p>为显示用来创建一个存储过程的CREATE语句，使用<code>SHOW CREATE PROCEDURE</code>语句：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE PROCEDURE ordertotal;</span><br></pre></td></tr></table></figure></div>

<p>为获得包括合适、由谁创建的详细信息的存储过程列表，使用<code>SHOW PROCEDURE STATUS</code></p>
<p><strong>限制过程状态结果</strong>：<code>SHOW PROCEDURE STATUS</code>列出所有存储过程</p>
<p>​	为限制其输出，可使用LIKE指定一个过滤模式</p>
<p>​	例如：</p>
<p>​	<code>SHOW PROCEDURE STATUs LIKE &#39;ordertotal&#39;;</code></p>
<hr>
<h1 id="使用游标"><a href="#使用游标" class="headerlink" title="使用游标"></a>使用游标</h1><p>什么是游标以及如何使用游标</p>
<h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><p><strong>需要MySQL 5</strong>：MySQL 5添加了对游标的支持</p>
<p>MySQL检索操作返回一组称为结果集的行<br>这组返回的行动是与SQL语句相匹配的行(0行或多行)<br>使用简单的SELECT语句，没法得到某些行，也不能在每次一行的处理所有行的简单方法(相对于成批的处理它们)</p>
<p>使用游标的原因：有时需要在检索出来的行中前进或后退一行或多行<br><strong>游标</strong>：是一个存储在MySQL服务器上的数据库查询<br>    它不是一条SELECT语句，而是被该语句检索出来的结果集<br>在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据</p>
<p>游标主要用于交互式应用<br>其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改</p>
<p><strong>只能用于存储过程</strong>：不像多数DBMS，MySQL游标只能用于存储过程(和函数)</p>
<h2 id="使用游标-1"><a href="#使用游标-1" class="headerlink" title="使用游标"></a>使用游标</h2><p>使用游标涉及几个明确的步骤：</p>
<ul>
<li>在能够使用游标前，必须声明(定义)它<br>  这个过程实际上没有检索数据，它只是定义要使用的SELECT语句</li>
<li>一旦声明后，必须打开游标以供使用<br>  这个过程用前面定义的SELECT语句吧数据书记检索出来</li>
<li>对于填有数据的游标，根据需要取出(检索)各行</li>
<li>在结束游标使用时，必须关闭游标</li>
</ul>
<p>在声明游标后，可以根据需要频繁的打开和关闭游标<br>在游标打开后 可根据需要频繁的执行取操作</p>
<h3 id="创建游标"><a href="#创建游标" class="headerlink" title="创建游标"></a>创建游标</h3><p>游标用DECLARE语句创建<br>DECLARE命名游标，并定义相应的SELECT语句，根据需要带WHERE和其他子句</p>
<p>例：下面语句定义了名为ordernumbers的游标，使用了可以检索所有orders的语句<br>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE processorders()</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE ordernumbers CURSOR</span><br><span class="line">	FOR</span><br><span class="line">	SELECT order_num FROM orders;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure></div>
<pre><code>这个存储过程并没有做很多事
DECLARE语句用来定义和命名游标，这里为ordernumbers
存储过程处理完成后，游标就消失(因为它局限于存储过程)
</code></pre>
<p>在定义游标之后，可以打开它</p>
<h3 id="打开和关闭游标"><a href="#打开和关闭游标" class="headerlink" title="打开和关闭游标"></a>打开和关闭游标</h3><p>游标用<code>OPEN CURSOR</code>语句来打开<br>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPEN ordernumbers;</span><br></pre></td></tr></table></figure></div>
<pre><code>在处理OPEN语句时执行查询，存储检索出的语句以供浏览和滚动
</code></pre>
<p>游标处理完成后，应当使用如下关闭游标：<br>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLOSE ordernumbers;</span><br></pre></td></tr></table></figure></div>
<pre><code>CLOSE释放游标使用的所有内部内存和资源
因此在每个游标不在需要时都应该关闭
</code></pre>
<p>在一个游标关闭后，如果没有重新开始，则不能使用它<br>但，使用声明过的游标不需要再次声明，用OPEN语句开始它就可以了</p>
<p><strong>隐含关闭</strong>：如果不明确关闭游标，MySQL将会在到达END语句时自动关闭它</p>
<p>下面是前面例子的修改版本：<br>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE processorders()</span><br><span class="line">BEGIN</span><br><span class="line">	-- 定义游标</span><br><span class="line">	DECLARE ordernumbers CURSOR</span><br><span class="line">	FOR</span><br><span class="line">	SELECT order_num FROM orders;</span><br><span class="line"></span><br><span class="line">	-- 打开游标</span><br><span class="line">	OPEN ordernumbers;</span><br><span class="line">	</span><br><span class="line">	-- 关闭游标</span><br><span class="line">	CLOSE ordernumbers;</span><br><span class="line"></span><br><span class="line">END;</span><br></pre></td></tr></table></figure></div>
<p>​	这个存储过程声明、打开和关闭一个游标<br>​	但对检索出的数据什么也没做</p>
<h3 id="使用游标数据"><a href="#使用游标数据" class="headerlink" title="使用游标数据"></a>使用游标数据</h3><p>在一个游标被打开后，可以使用FETCH语句分别访问它的每一行<br><strong>FETCH</strong>指定检索声明数据(所需的列)，检索出来的数据存储在什么地方<br>它还向前移动游标中的内部行指针，使下一条FETCH语句检索下一行(不重复读取同一行)</p>
<p>例：从游标中检索单个行(第一行)：<br>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">CREATR PROCEDUER processorders()</span><br><span class="line">BEGIN</span><br><span class="line">	</span><br><span class="line">	-- 声明局部变量</span><br><span class="line">	DECLARE o INT;</span><br><span class="line"></span><br><span class="line">	-- 定义游标</span><br><span class="line">	DECLARE ordernumbers CURSOR</span><br><span class="line">	FOR</span><br><span class="line">	SELECT order_num FROM orders;</span><br><span class="line"></span><br><span class="line">	-- 打开游标</span><br><span class="line">	OPEN ordernumbers</span><br><span class="line"></span><br><span class="line">	-- 获取ordernumbers</span><br><span class="line">	FETCH ordernumbers INTO o&#x27;</span><br><span class="line"></span><br><span class="line">	-- 关闭游标</span><br><span class="line">	CLOSE ordernumbers;</span><br><span class="line"></span><br><span class="line">END;</span><br></pre></td></tr></table></figure></div>
<p><code>FETCH</code>用来检索当前行的order_num列(将自动从第一行开始)到一个名为o的局部声明的变量中<br>    对检索出的数据不做任何处理</p>
<p>下例：循环检索数据，从第一行到最后一行：<br>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE processorders()</span><br><span class="line">BEGIN</span><br><span class="line">	-- 声明局部变量</span><br><span class="line">	DECLARE done BOOLEAN DEFAULT 0;</span><br><span class="line">	DECLARE o INT;</span><br><span class="line"></span><br><span class="line">	-- 定义游标</span><br><span class="line">	DECLARE ordernumbers CURSOR</span><br><span class="line">	FOR</span><br><span class="line">	SELECT order_num FROM orders;</span><br><span class="line"></span><br><span class="line">	-- 声明 continue 处理程序</span><br><span class="line">	DECLARE CONTINUE HANDLER FOR SQLSTATE &#x27;02000&#x27; SET done=1;</span><br><span class="line"></span><br><span class="line">	-- 打开游标</span><br><span class="line">	OPEN ordernumbers;</span><br><span class="line"></span><br><span class="line">	-- 循环遍历所有行</span><br><span class="line">	REPEAT</span><br><span class="line"></span><br><span class="line">		-- 获取ordernumbers</span><br><span class="line">		FETCH ordernumbers INTO o;</span><br><span class="line"></span><br><span class="line">	-- 循环结束</span><br><span class="line">	UNTIL done END REPEAT;</span><br><span class="line"></span><br><span class="line">	-- 关闭游标</span><br><span class="line">	CLOSE ordernumbers;</span><br><span class="line"></span><br><span class="line">END;</span><br></pre></td></tr></table></figure></div>
<p>使用FETCH检索当前order_num到声明的名为o的变量中<br>与前一个例子不同的是，这个例子中的FETCH是在REPEAT内</p>
<ul>
<li>因此它反复执行直到done为真(由<code>UNTIL done END REPEAT;</code>规定)</li>
<li>为使其起作用，用一个DEFAULT 0(假，不结束)定义变量done</li>
</ul>
<p>那么，done怎样才能在结束时被设置为真？<br>使用以下语句：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLART CONTINUE HANDLER FOR SQLSTARTE ’02000‘ SET done=1;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>此语句定义了一个<code>CONTINUE HANDLER</code>(条件句柄)<br>  是在条件出现时被执行的代码</li>
<li>它指出当<code>SQLSTATE &#39;02000&#39;</code>出现时，<code>SET done=1</code></li>
<li><code>SQLSTATE &#39;02000&#39;</code>是一个未找到条件<br>  当REPERAT由于没有更多的行供循环而不能继续时，出现这个条件</li>
</ul>
<p><strong>MySQL的错误代码</strong>：关于MySQL 5使用的MySQL错误代码列表，参阅<a class="link"   target="_blank" rel="noopener" href="http://dev.mysql.com/doc/mysql/en/error-handling.html" >http://dev.mysql.com/doc/mysql/en/error-handling.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><strong>DECLAER语句的次序</strong>：DECLARE语句的发布存在特定的次序<br>    用DECLARE语句定义的<strong>局部变量</strong>必须在定义任意<strong>游标</strong>或<strong>句柄</strong>之前定义<br>    而<strong>句柄</strong>必须在<strong>游标</strong>之后定义<br>    不遵守此顺序将产生错误消息</p>
<p>如果调用这个存储过程</p>
<ul>
<li>将定义几个变量和一个<code>CONTINUE HANDLER</code></li>
<li>定义并打开一个游标</li>
<li>重复读取所有行</li>
<li>然后关闭游标</li>
</ul>
<p>如果一切正常，则可以在循环内放入任意需要的处理(在FETCH语句之后，循环结束之前)</p>
<p><strong>重复或循环？</strong>：除这里使用的REPEAT语句外，MySQL还支持循环语句<br>    它可用来重复执行代码，直到使用LEAVE语句手动退出位置<br>    通常REPEAT语句的语法使它更适合于对游标进行循环</p>
<p>为把这些内容组织起来，下面给出游标存储过程阳历的更进一步修改的版本<br>这次对去除的数据进行某种实际的处理：<br>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE processorders()</span><br><span class="line">BEGIN</span><br><span class="line">	</span><br><span class="line">	-- 定义局部变量</span><br><span class="line">	DECLARE done BOOLEAN DEFAULT 0;</span><br><span class="line">	DECLARE o INT;</span><br><span class="line">	DECLARE t DECIMAL(8, 2);</span><br><span class="line"></span><br><span class="line">	-- 声明游标</span><br><span class="line">	DECLARE ordernumbers CURSOR</span><br><span class="line">	FOR</span><br><span class="line">	SELECT order_num FROM orders;</span><br><span class="line"></span><br><span class="line">	-- 定义CONTINUE HANDLER</span><br><span class="line">	DECLARE CONTINUE HANDLER FOR SQLSRARE &#x27;02000&#x27; SET done=1;</span><br><span class="line"></span><br><span class="line">	-- 创建表以存储结果</span><br><span class="line">	CREATR TABLE IF NOT EXISTS ordertotals</span><br><span class="line">		(order_num INT, total DECIMAL(8, 2));</span><br><span class="line"></span><br><span class="line">	-- 打开游标</span><br><span class="line">	OPEN ordernumbers;</span><br><span class="line"></span><br><span class="line">	-- 循环遍历所有行</span><br><span class="line">	REPEAT</span><br><span class="line">	</span><br><span class="line">		-- 获取ordernumber</span><br><span class="line">		FETCH ordernumbers INTO o;</span><br><span class="line"></span><br><span class="line">		-- 获取total总计</span><br><span class="line">		CALL ordertotal(o, 1, t);</span><br><span class="line"></span><br><span class="line">		-- 将 order 和 total 插入到 ordertotals 中</span><br><span class="line">		INSERT INTO ordertotals(order_num, total)</span><br><span class="line">		VALUES(o, t);</span><br><span class="line"></span><br><span class="line">	-- 循环结束</span><br><span class="line">	UNTIL done END REPEAT;</span><br><span class="line"></span><br><span class="line">	-- 关闭游标</span><br><span class="line">	CLOSE ordernumbers;</span><br><span class="line"></span><br><span class="line">END;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>本例中，增加了另一个名为t的变量(存储每个total的合计)</li>
<li>此存储过程还在运行中创建了一个新表(如果它不存在的话)，名为ordertotals<br>  这个表将保存存储过程生成的结果</li>
<li>FETCH像以前一样取每个order_num<br>  然后用CALL执行另一个存储过程(之前创建的)来计算每个合计(结果存储到t)</li>
<li>最后，用INSERT保存每个订单的订单号和合计</li>
</ul>
<p>此存储过程不返回数据，但它能够创建和填充另一个表<br>可以用一条简单的SELECT语句查看该表：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM ordertotals;</span><br></pre></td></tr></table></figure></div>

<p>这样就得到了存储过程、游标、逐行处理以及存储过程条用其他存储过程的一个完整的工作样例</p>
<hr>
<h1 id="使用触发器"><a href="#使用触发器" class="headerlink" title="使用触发器"></a>使用触发器</h1><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p><strong>需要MySQL 5</strong></p>
<p>MySQL在需要时被执行，存储过程也是如此</p>
<p>如果想要某条语句(或某些语句)在事件发生时自动执行呢</p>
<p>例：在某个表发生更改时自动处理，使用触发器</p>
<p><strong>触发器</strong>：是MySQL相应以下任意语句而自动执行的一条MySQL语句</p>
<p>​	(或位于<code>BEGIN</code>和<code>END</code>语句之间的一组语句)</p>
<ul>
<li><code>DELETE</code></li>
<li><code>INSERT</code></li>
<li><code>UPDATE</code></li>
</ul>
<p>其他MySQL语句不支持触发器</p>
<h2 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h2><p>在创建触发器时，需要给出4条信息：</p>
<ul>
<li>唯一的触发器名</li>
<li>触发器关联的表</li>
<li>触发器应该相应的活动(DELETE、INSERT或UPDATE)</li>
<li>触发器何时执行(处理之前或之后)</li>
</ul>
<p><strong>保持每个数据库的触发器名唯一</strong>：在MySQL5中，触发器名必须在每个表中唯一，但不是在每个数据库中唯一</p>
<p>​	在其他每个数据库触发器名必须唯一的DBMS中是不允许的，而且未来MySQL版本可能会使命名规则更为严格</p>
<p>​	因此，最好在数据库范围内使用唯一的触发器名</p>
<p>触发器用<code>CREATE TRIGGER</code>语句创建：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER newproduct AFTER INSERT ON products</span><br><span class="line">FOR EACH ROW SELECT &#x27;Product added&#x27;;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>CREATE TRIGGER</code>用来创建名为newproduct的新触发器</li>
<li>触发器可在一个操作发生之前或之后执行<ul>
<li>此处给出<code>AFTER INSERT</code>，所以此触发器将在INSERT语句成功执行后执行</li>
</ul>
</li>
<li>这个触发器还指定<code>FOR EACH ROW</code><ul>
<li>因此代码对每个插入行执行</li>
</ul>
</li>
</ul>
<p>此例中，文本<code>Product added</code>将对每个插入的行显示一次</p>
<p><strong>仅支持表</strong>：只有表才支持触发器，视图不支持(临时表也不支持)</p>
<p>触发器按每个表每个事件每次的定义</p>
<p>​	每个表每个事件每次只允许一个触发器</p>
<p>因此每个表最多支持6个触发器(每条<code>INSERT</code>、<code>UPDATE</code>和<code>DELETE</code>的之前和之后)</p>
<p>单一触发器不能与多个事件或多个表关联</p>
<p>​	所以如果需要对一个INSERT和UPDARE操作执行的触发器，则应该定义两个触发器</p>
<p><strong>触发器失败</strong>：如果BEFORE触发器失败，则MySQL将不执行请求的操作</p>
<p>​	此外没如果BEFORE触发器或语句本身失败，MySQL将不执行AFTER触发器(如果有的话)</p>
<h2 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h2><p>为删除一个触发器，可使用<code>DROP TRIGGER</code>语句：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TRIGGER newproduct;</span><br></pre></td></tr></table></figure></div>

<p>​	触发器不能更新或覆盖</p>
<p>为了修改一个触发器，必须先删除它，然后再重新创建</p>
<h2 id="使用触发器-1"><a href="#使用触发器-1" class="headerlink" title="使用触发器"></a>使用触发器</h2><p>所支持的每种触发器类型以及它们的差别</p>
<h3 id="INSERT触发器"><a href="#INSERT触发器" class="headerlink" title="INSERT触发器"></a>INSERT触发器</h3><p>在INSERT语句执行之前或之后执行</p>
<p>需要知道以下几点：</p>
<ul>
<li>在<code>INSERT</code>触发器代码内，可引用一个名为<code>NEW</code>的虚拟表，访问被插入的行</li>
<li>在<code>BEFORE INSERT</code>触发器中，<code>NEW</code>中的值也可以被更新(允许更改被插入的值)</li>
<li>对于<code>AUTO_INCREMENT</code>列，<code>NEW</code>在<code>INSERT</code>执行之前包含0，在<code>INSERT</code>执行之后包含新的自动生成值</li>
</ul>
<p>例：<code>AUTO_INCREMENT</code>列具有MySQL自动赋予的值</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER neworder AFTER INSERT ON orders</span><br><span class="line">FOR EACH ROW SELECT NEW,order_num;</span><br></pre></td></tr></table></figure></div>

<p>但这是一种确定新生成的值的更好的方法</p>
<p><strong>DEFORE或AFTER？</strong>：通常，将BEFORE用于数据验证和净化(目的是保证插入表中的数据确实是需要的数据)</p>
<p>​	本提示也适用于UPDATE触发器</p>
<h3 id="DELETE触发器"><a href="#DELETE触发器" class="headerlink" title="DELETE触发器"></a>DELETE触发器</h3><p>在DELETE语句执行之前或之后执行</p>
<p>需要知道以下两点：</p>
<ul>
<li>在DELETE触发器代码内，可以引用一个名为OLD的虚拟表，访问被删除的行</li>
<li>OLD中的值全部都是只读的，不能更新</li>
</ul>
<p>例：使用OLD保存将要被删除的行到一个存档表中</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER deleteorder BEFORE DELETE ON orders</span><br><span class="line">FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">	INSERT INTO archive_orders(order_num, order_date, cust_id)</span><br><span class="line">	VALUES(OLD.order_num, OLD.order_date, OLD.cust_id);</span><br><span class="line">END;</span><br></pre></td></tr></table></figure></div>



<p>使用<code>BEFORE DELETE</code>触发器的优点(相对于<code>AFTER DELETE</code>触发器来说)为：如果由于某种原因，订单不能存档，DELETE本身将被放弃</p>
<p><strong>多语句触发器</strong>：触发器deleteorder使用<code>BEGIN</code>和<code>END</code>语句标记触发器体</p>
<p>​	这并不是必须的，但也没有害处</p>
<p>​	使用<code>BEGIN END</code>块的好处是触发器能容纳多条SQL语句(在<code>BEGIN END</code>块中一条挨着一条)</p>
<h3 id="UPDATE触发器"><a href="#UPDATE触发器" class="headerlink" title="UPDATE触发器"></a>UPDATE触发器</h3><p>在UPDATE语句执行之前或之后执行</p>
<p>需要知道以下几点：</p>
<ul>
<li>在UPDATE触发器代码中<ul>
<li>可以引用一个名为OLD的虚拟表访问以前(UPDATE语句前)的值</li>
<li>引用一个名为NEW的虚拟表访问新更新的值</li>
</ul>
</li>
<li>在<code>BEFORE UPDATE</code>触发器中，NEW中的值可能也被更新(允许更改将要用于UPDATE语句中的值)</li>
<li>OLD中的值全都是只读的，不能更新</li>
</ul>
<p>例：保证州名缩写总是大写(不管UPDATE语句中给出的是大写还是小写)</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER updatevendor BEFORE UPDATE ON vendors</span><br><span class="line">FOR EACH ROW SET NEW,vend_state = Upper(NEW.vend_state);</span><br></pre></td></tr></table></figure></div>

<p>显然，任何数据净化都需要再UPDATE语句之前进行，就像此例中一样</p>
<p>​	每次更新一个值时，<code>NEW.vend_state</code>中的值(将用来更新表行的值)都用<code>Upper(NEW.vend_state)</code>替换</p>
<h3 id="关于触发器的进一步介绍"><a href="#关于触发器的进一步介绍" class="headerlink" title="关于触发器的进一步介绍"></a>关于触发器的进一步介绍</h3><p>一些使用触发器时需要记住的重点：</p>
<ul>
<li>与其他DBMS相比，MySQL 5中支持的触发器相当初级<ul>
<li>未来的MySQL版本中有一些改进和增强触发器支持的计划</li>
</ul>
</li>
<li>创建触发器可能需要特殊的安全访问权限，但是，触发器的执行是自动的<ul>
<li>如果<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>语句能够执行，则相关的触发器也能执行</li>
</ul>
</li>
<li>应该用触发器来保证数据的一致性(大小写、格式等)<ul>
<li>在触发器中执行这种类型的处理的优点是：它总是进行这种处理，而且是透明的进行，与客户机应用无关</li>
</ul>
</li>
<li>触发器的一种非常有意义的使用是：创建审计跟踪<ul>
<li>使用触发器，把更改(如果需要，甚至还有之前和之后的状态)记录到另一个表非常容易</li>
</ul>
</li>
<li>遗憾的是，MySQL触发器中不支持CALL语句<ul>
<li>这表示不能从触发器内调用存储过程</li>
<li>所需的存储过程代码需要复制到触发器内</li>
</ul>
</li>
</ul>
<hr>
<h1 id="管理事务处理"><a href="#管理事务处理" class="headerlink" title="管理事务处理"></a>管理事务处理</h1><p>什么是事务处理 以及 如何利用<code>COMMIT</code>和<code>ROLLBACK</code>语句来管理事务处理</p>
<h2 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h2><p><strong>并非所有引擎都支持事务处理</strong>：MySQL支持几种基本的数据库引擎</p>
<p>​	并非所有引擎都支持明确的事务处理管理</p>
<p>MyISAM和InnoDB是两种最常使用的引擎</p>
<ul>
<li>前者不支持明确的事务处理管理，而后者支持</li>
</ul>
<p>如果应用中需要事务处理功能，则一定要使用正确的引擎类型</p>
<p><strong>事务处理</strong>可以用来维护数据库的完整性，它保证成批的MySQL操作要么完全执行，要么完全不执行</p>
<p>关系数据库设计吧数据鵆在多个表中，使数据更容易操纵、维护和重用</p>
<p>​	在某种程度上说，设计良好的数据库模式都是关联的</p>
<p>事务处理是一种机制，用来管理必须成批执行的MySQL操作，以保证数据库不包含不完整的操作结果</p>
<p>利用事务处理，可以保证一组操作不会中途停止，它们或者作为整体执行，或者完全不执行(除非明确指示)</p>
<p>如果没有错误发生，整组语句提交给(写到)数据库表</p>
<p>如果发生错误，则进行回退(撤销)以恢复数据库到某个已知且安全的状态</p>
<p>在使用事务和事务处理时，有几个关键词汇反复出现</p>
<p>下面是关于事务处理需要知道的几个术语：</p>
<ul>
<li><strong>事务</strong>：指一组SQL语句</li>
<li><strong>回退</strong>：指撤销指定SQL语句的过程</li>
<li><strong>提交</strong>：指将未存储的SQL语句结果写入数据库表</li>
<li><strong>保留点</strong>：指事务处理中设置的临时占位符，可对它发布回退(与回退整个事务处理不同)</li>
</ul>
<h2 id="控制事务处理"><a href="#控制事务处理" class="headerlink" title="控制事务处理"></a>控制事务处理</h2><p>管理事务处理的关键在于：将SQL语句组分解为逻辑块，并明确规定数据何时应该回退，何时不应该回退</p>
<p>MySQL使用下面的语句来标识事务的开始：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION</span><br></pre></td></tr></table></figure></div>



<h3 id="使用ROLLBACK"><a href="#使用ROLLBACK" class="headerlink" title="使用ROLLBACK"></a>使用ROLLBACK</h3><p>MySQL的ROOLBACK命令用来回退(撤销)MySQL语句</p>
<p>例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM ordertotals;</span><br><span class="line">START TRANSACTION;</span><br><span class="line">DELETE FROM ordertotals;</span><br><span class="line">SELECT * FROM ordertotals;</span><br><span class="line">ROOLBACK;</span><br><span class="line">SELECT * FROM ordertotals;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>首先执行一条SELECT以显示该表不为空</li>
<li>然后开始一个事务处理<ul>
<li>用一条DELETE语句删除ordertotals中的所有行</li>
<li>另一条SELECT语句验证ordertotals确实为空</li>
<li>这时用一条ROLLBACK语句回退<code>START TRANSACTION</code>之后的所有语句</li>
</ul>
</li>
<li>最后一条SELECT语句显示该表不为空</li>
</ul>
<p>显然，ROLLBACK只能在一个事务处理内使用(在执行一条<code>START TRANSACTION</code>命令之后)</p>
<p><strong>哪些语句可以回退？</strong>：事务处理用来管理<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>语句</p>
<ul>
<li><p>不能回退SELECT语句(这样做也没有什么意义)</p>
</li>
<li><p>不能回退CREATE或DROP操作</p>
<ul>
<li>事务处理块中可以使用这两条语句，但如果你执行回退，它们不会被撤销</li>
</ul>
</li>
</ul>
<h3 id="使用COMMIT"><a href="#使用COMMIT" class="headerlink" title="使用COMMIT"></a>使用COMMIT</h3><p>一般的MySQL语句都是直接针对数据库表执行和编写的</p>
<p>​	这就是所谓的<strong>隐含提交</strong>：即提交(写或保存)操作是自动进行的</p>
<p>但，在事务处理块中，提交不会隐含的进行</p>
<p>为进行明确的提交，使用COMMIT语句，如下所示：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION;</span><br><span class="line">DELETE FROM orderitems WHERE order_num = 20010;</span><br><span class="line">DELETE FROM orders WHERE order_num = 20010;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure></div>

<p>最后的COMMIT语句不仅在不出错时写出更改</p>
<p>如果第一条DELETE起作用，但第二条失败，则DELETE不会提交(实际上，它是被自动撤销的)</p>
<p><strong>隐含事务关闭</strong>：当COMMIT或ROLLBACK语句执行后，事务会自动关闭(将来的更改会隐含提交)</p>
<h3 id="使用保留点"><a href="#使用保留点" class="headerlink" title="使用保留点"></a>使用保留点</h3><p>简单的ROLLBACK和COMMIT语句就可以写入或撤销整个事务处理</p>
<p>​	但，只是对简单的事务处理才能这样做，更复杂的事务处理可能需要部分提交或回退</p>
<p>为了支持回退部分事务处理，必须能在事务处理块中合适的位置放置占位符</p>
<p>​	这样，如果需要回退，可以回退到某个占位符</p>
<p>这些占位符称为保留点</p>
<p>为了创建占位符，可使用SAVEPOINT语句：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SAVEPOINT delete1;</span><br></pre></td></tr></table></figure></div>

<p>每个保留点都取标志它的唯一名字，以便在回退时，MySQL知道要回退到何处</p>
<p>为了回退到本例给出的保留点，可如下进行：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROLLBACK TO delete1;</span><br></pre></td></tr></table></figure></div>



<p><strong>保留点越多越好</strong>：可以在MySQL代码中设置任意多的保留点，越多越好</p>
<p>​	为什么：因为保留点越多，就越能按自己的意愿灵活的进行回退</p>
<p><strong>释放保留点</strong>：保留点在事务处理完成(执行一条ROLLBACK或COMMIT)后自动释放</p>
<p>​	自MySQL5以来，也可以用<code>RELEASE SAVEPOINT</code>明确的释放保留点</p>
<h3 id="更改默认的提交行为"><a href="#更改默认的提交行为" class="headerlink" title="更改默认的提交行为"></a>更改默认的提交行为</h3><p>默认的MySQL行为是自动提交所有更改</p>
<p>换句话说，任何时候执行一条MySQL语句，该语句实际上都是针对表执行的，而且所做的更改立即生效</p>
<p>为指示MySQL不自动提交更改，需要使用以下语句：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET autocommit=0;</span><br></pre></td></tr></table></figure></div>

<p>autocommit标志决定是否自动提交更改，不管有没有COMMIT语句</p>
<p>​	设置autocommit为0(假)指示MySQL不自动提交更改(直到autcommit被设置为真为止)</p>
<p><strong>标志为连接专用</strong>：autocommit标志是针对每个连接而不是服务器的</p>
<hr>
<h1 id="全球化和本地化"><a href="#全球化和本地化" class="headerlink" title="全球化和本地化"></a>全球化和本地化</h1><p>MySQL处理不同字符集和语言的基础知识</p>
<h2 id="字符集和校对顺序"><a href="#字符集和校对顺序" class="headerlink" title="字符集和校对顺序"></a>字符集和校对顺序</h2><p>数据库表被用来存储和检索数据，不同的语言和字符集需要以不同的方式存储和检索</p>
<p>​	因此，MySQL需要适应不同的字符集（不同的字母和字符），适应不同的排序和检索数据的方法</p>
<p>在讨论多种语言和字符集时，将会遇到以下重要术语：</p>
<ul>
<li><p><strong>字符集</strong>：为字母和符号的集合</p>
</li>
<li><p><strong>编码</strong>：为某个字符集成员的内部表示</p>
</li>
<li><p><strong>校对</strong>：为规定字符如何比较的指令</p>
</li>
</ul>
<p><strong>校对为什么重要</strong>：大小写的区分不仅影响排序(如用<code>ORDER BY</code>排序数据)，还影响搜索(如<code>WHERE</code>)</p>
<p>​	在使用法文或德文等字符时更复杂，在使用不基于拉丁文的字符集时，情况更为复杂</p>
<p>在MySQL的正常数据库活动(SELECT、INSERT等)中，不需要操心太多东西</p>
<p>使用何种字符集和校对的决定在服务器、数据库和表级进行</p>
<h2 id="使用字符集和校对顺序"><a href="#使用字符集和校对顺序" class="headerlink" title="使用字符集和校对顺序"></a>使用字符集和校对顺序</h2><p>MySQL支持众多的字符集</p>
<p>为查看所支持的字符集完整列表，使用以下语句：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CHARACTER SET;</span><br></pre></td></tr></table></figure></div>

<p>这条语句显示所有可用的字符集以及每个字符集的描述和默认校对</p>
<p>为查看所支持校对的完整列表，使用以下语句：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW COLLATION;</span><br></pre></td></tr></table></figure></div>

<p>显式所有可用的校对，以及它们适用的字符集</p>
<p>​	可以看到有的字符集具有不止一种校对，而且许多校对出现两次，一次区分大小写(<code>_cs</code>)，一次不区分大小写(<code>_ci</code>)</p>
<p>通常系统管理在安装时定义一个默认的字符集和校对</p>
<p>此外，也可以在创建数据库时，指定默认的字符集和校对</p>
<p>为了确定所用的字符集和校对，可以使用以下语句：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;character%&#x27;;</span><br><span class="line">SHOW VARIABLES LIKE &#x27;collation%&#x27;;</span><br></pre></td></tr></table></figure></div>

<p>实际上，字符集很少是服务器范围(甚至数据库范围)的设置</p>
<p>​	不同的表，甚至不同的列都可能需要不同的字符集，而且两者都是可以在创建表时指定</p>
<p>为了给表指定字符集和校对，可使用带子句的<code>CREATE TABLE</code>：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE mytable</span><br><span class="line">(</span><br><span class="line">	columnn1	INT,</span><br><span class="line">	columnn2	VARCHAR(10)</span><br><span class="line">) DEFAULT CHARACTER SET hebrew</span><br><span class="line">  COLLATE hebrew_general_ci;</span><br></pre></td></tr></table></figure></div>

<p>这个例子中指定了<code>CHARACTER SET</code>和<code>COLLATE</code>两者</p>
<p>一般MySQL如下确定使用什么样的字符集和校对：</p>
<ul>
<li>如果指定<code>CHARACTER SET</code>和<code>COLLATE</code>两者，则使用这些值</li>
<li>如果只指定<code>CHARACTER SET</code>，则使用此字符集及其默认的校对(如<code>SHOW CHARACTER SET</code>的结果中所示)</li>
<li>如果即不指定<code>CHARACTER SET</code>，也不指定<code>COLLATE</code>，则使用数据库默认</li>
</ul>
<p>除了能指定字符集和校对的表范围外，MySQL还允许对每个列设置它们，如下所示：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE mytable</span><br><span class="line">(</span><br><span class="line">	columnn1	INT</span><br><span class="line">	colummn2	VARCHAR(10)</span><br><span class="line">	columnn3	VARCHAR(10) CHARACTER SET latin1 COLLATE latin1_general_ci</span><br><span class="line">) DEFAULT CHARACTER SET hebrew</span><br><span class="line">  COLLATE hebrew_general_ci;</span><br></pre></td></tr></table></figure></div>

<p>这里对整个表以及一个特定的列指定了CHARACTER SET和COLLATE</p>
<p>校对在对用<code>ORDER BY</code>子句检索出来的数据排序时起重要的作用</p>
<p>如果需要用于创建表时不同的校对顺序排序特定的SELECT语句，可以在SELECT语句自身中进行：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM customers</span><br><span class="line">ORDER BY lastname, firstname COLLATE latin1_general_cs;</span><br></pre></td></tr></table></figure></div>

<p>此SELECT使用COLLATE指定一个备用的校对顺序(此例中为区分大小写的校对)</p>
<p>​	这显然将会影响到结果排序的次序</p>
<p><strong>临时区分大小写</strong>：上面的SELECT语句演示了在通常不区分大小写的表上进行区分大小写搜索的一种技术</p>
<p>​	当然，反过来也是可以的</p>
<p><strong>SELECT的其他COLLATE子句</strong>：除了这里看到的在<code>ORDER BY</code>子句中使用以外，COLLATE还可以用于<code>GROUP BY</code>、<code>HAVING</code>、聚集函数、别名等</p>
<p>最后，值得注意点是，如果绝对需要，穿可以在字符集之间进行转换</p>
<p>​	为此，使用<code>Cast()</code>或<code>Convert()</code>函数</p>
<hr>
<h1 id="安全管理"><a href="#安全管理" class="headerlink" title="安全管理"></a>安全管理</h1><p>数据库服务器通常包含关键的数据，确保这些数据的安全和完整需要利用访问控制</p>
<h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><p>MySQL服务器的安全基础时：用户应该对他们需要的数据具有适当的访问权，既不能多也不能少</p>
<p>​	即，用户不能对过多的数据具有过多的访问权</p>
<p>   <strong>访问控制</strong>：管理访问控制需要创建和管理用户账号</p>
<p>在现实世界的日常工作中，决不能使用root</p>
<p>​	应该创建一系列的账号，有的用于管理，有的供用户使用，有的供开发人员使用，等等</p>
<p><strong>防止无意的错误</strong>：重要的是注意到，访问控制的目的不仅仅是防止用户的恶意企图</p>
<p>​	数据梦魇更为常见的是无意识错误的结果，如打错MySQL语句，在不适合的数据库中操作或其他一些用户错误</p>
<p>​	通过保证用户不能执行他们不应该执行的语句，访问控制有助于避免这些情况的发生</p>
<p><strong>不要使用root</strong>：应该严肃对待root登录的使用</p>
<p>​	仅在绝对需要时使用它(或许在你不能登录其他管理账号时使用)</p>
<p>​	不应该在日常的MySQL操作中使用root</p>
<h2 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h2><p>MySQL用户账号和信息存储在名为mysql的MySQL数据库中</p>
<p>一般不需要直接访问mysql数据库和表，但有时需要直接访问</p>
<p>需要直接访问它的时机之一是在需要获得多于用户账号列表时</p>
<p>​	为此，可使用以下代码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">USE mySql;</span><br><span class="line">SELECT user FROM user;</span><br></pre></td></tr></table></figure></div>

<p>mysql数据库有一个名为user的表，它包含所有用户账号</p>
<p>user表有一个名为user的列，它存储用户登录名</p>
<p><strong>用多个客户机进行试验</strong>：试验对用户账号和权限进行更改的最好办法是打开多个数据库客户机(如mysql命令行使用程序的多个副本)，一个作为管理登录，其他作为被测试的用户登录</p>
<h3 id="创建用户账号"><a href="#创建用户账号" class="headerlink" title="创建用户账号"></a>创建用户账号</h3><p>为了创建一个新用户账号，使用<code>CREATE USER</code>语句，如下所示：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER ben IDENTIFIED BY &#x27;p@$$w0rd&#x27;;</span><br></pre></td></tr></table></figure></div>

<p><code>CREATE USER</code>创建一个新用户账号</p>
<p>在创建用户账号时不一定需要口令，不过这个例子用<code>IDENTIFIED BY &#39;p@$$w0rd&#39;</code>给出了一个口令</p>
<p>​	如果再次列出用户账号，将会在输出中看到新账号</p>
<p><strong>指定散列口令</strong>：<code>IDENTIDIED BY</code>指定的口令为纯文本</p>
<p>​	MySQL将在保存到user表之前对其进行加密</p>
<p>为了作为散列值指定口令，使用<code>IDENTIDIED BY PASSWORD</code></p>
<p><strong>使用GRANT或INSERT</strong>：</p>
<p>​	GRANT语句也可以创建用户账号，但一般来说<code>CREATE USER</code>是最清楚和最简单的句子</p>
<p>此外，也可以通过直接插入行到user表来增加用户，不过为安全起见，一般不建议这样做</p>
<p>MySQL用来存储用户账号信息的表(以及表模式等)极为重要，对它们的任何毁坏都可能严重的伤害到MySQL服务器</p>
<p>​	因此，相对于直接处理来说，最好是用标记和函数来处理这些表</p>
<p>为重新命名一个用户账号，使用<code>RENAME USER</code>语句，如下所示：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RENAME USER ben TO bforta;</span><br></pre></td></tr></table></figure></div>

<p><strong>MySQL 5之前</strong>：仅MySQL5或之后的版本支持<code>RENAME USER</code></p>
<p>​	为了在以前的MySQL中重命名一个用户，可使用<code>UPDATE</code>直接更新user表</p>
<h3 id="删除用户账号"><a href="#删除用户账号" class="headerlink" title="删除用户账号"></a>删除用户账号</h3><p>为了删除一个用户账号(以及相关的权限)，使用<code>DROP USER</code>语句，如下所示：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP USER bforta;</span><br></pre></td></tr></table></figure></div>

<p><strong>MySQL 5之前</strong>：</p>
<p>​	自MySQL5以来，<code>DROP USER</code>删除用户账号和所有相关的账号权限</p>
<p>​	在MySQL5以前，<code>DROP USER</code>只能用来删除用户账号，不能删除相关的权限</p>
<p>因此如果使用旧版本的MySQL，需要先用<code>REVOKE</code>删除与账号相关的权限，然后再用<code>DROP USER</code>删除账号</p>
<h3 id="设置访问权限"><a href="#设置访问权限" class="headerlink" title="设置访问权限"></a>设置访问权限</h3><p>在创建用户账号后，必须接着分配访问权限</p>
<p>新创建的用户账号没有访问权限</p>
<p>​	它们能登录MySQL，但不能看到数据，不能执行任何数据库操作</p>
<p>为看到赋予用户账号的权限，使用<code>SHOW GRANTS FOR</code>，如下所示：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW GRANTS FOR bforta;</span><br></pre></td></tr></table></figure></div>

<p>输出结果显示bforta有一个权限<code>USAGE ON *.*</code></p>
<ul>
<li>USAGE表示根本没有权限(很不直观罢)</li>
</ul>
<p>所以此结果教室在任意数据库和任意表上对任何东西都没有权限</p>
<p>**用户定义为<code>user@host</code>**：MySQL的权限用用户名和主机名结合定义</p>
<p>​	如果不指定主机名，则使用默认的主机名<code>%</code>(授予用户访问权限而不管主机名)</p>
<p>为设置权限，使用GRANT语句</p>
<p>GRANT要求至少给出以下信息：</p>
<ul>
<li>要授予的权限</li>
<li>被授予访问权限的数据库或表</li>
<li>用户名</li>
</ul>
<p>下例给出GRANT的用法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT SELECT ON crashcourse.* TO bforta;</span><br></pre></td></tr></table></figure></div>

<p>此GRANT允许用户在<code>crashcourse.*</code>(crashcourse数据库的所有表)上使用SELECT</p>
<p>​	通过只授予SELECT访问权限，用户bforta对crashcourse数据库中的所有数据具有只读访问权限</p>
<p><code>SHOW GRANTS</code>反映这个更改：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW GRANTS FOR bforta;</span><br></pre></td></tr></table></figure></div>

<p>每个GRANT添加(或更新)用户的一个权限</p>
<p>​	MySQL读取所有授权，并根据它们确定权限</p>
<p>GRANT的反操作为REVOKE，用它来撤销特定的权限：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVOKE SELECT ON crashcourse.* FROM bforta;</span><br></pre></td></tr></table></figure></div>

<p>​	这条REVOKE语句取消刚刚赋予用户bforta的SELECT访问权限</p>
<p>被撤销的访问权限必须存在，否则会出错</p>
<p><code>GRANT</code>和<code>REVOKE</code>可在几个层次上控制访问权限：</p>
<ul>
<li>整个服务器，使用<code>GRANT ALL</code>和<code>REVOKE ALL</code></li>
<li>整个数据库，使用<code>ON database.*</code></li>
<li>特定的表，使用<code>ON database.table</code></li>
<li>特定的列</li>
<li>特定的存储过程</li>
</ul>
<p>下表列出可以授予或撤销的每个权限：</p>
<p>表 权限</p>
<table>
<thead>
<tr>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ALL</code></td>
<td>除<code>GRANT OPTION</code>外的所有权限</td>
</tr>
<tr>
<td><code>ALTER</code></td>
<td>使用<code>ALTER TABLE</code></td>
</tr>
<tr>
<td><code>ALTER ROUTINE</code></td>
<td>使用<code>ALTER PROCEDURE</code>和<code>DROP PROCEDURE</code></td>
</tr>
<tr>
<td><code>CREATE</code></td>
<td>使用<code>CREATE TABLE</code></td>
</tr>
<tr>
<td><code>CREATE ROUTINE</code></td>
<td>使用<code>CREATE PROCEDURE</code></td>
</tr>
<tr>
<td><code>CREATE TEMPORARY TABLES</code></td>
<td>使用<code>CREATE TEMPORARY TABLE</code></td>
</tr>
<tr>
<td><code>CREATE USER</code></td>
<td>使用<code>CREATE USER</code>、<code>DROP USER</code>、<code>RENAME USER</code>和<code>REVOKE ALL PRIVILEGES</code></td>
</tr>
<tr>
<td><code>CREATE VIEW</code></td>
<td>使用<code>CREATE VIEW</code></td>
</tr>
<tr>
<td><code>DELETE</code></td>
<td>使用<code>DELETE</code></td>
</tr>
<tr>
<td><code>DROP</code></td>
<td>使用<code>DROP TABLE</code></td>
</tr>
<tr>
<td><code>EXECUTE</code></td>
<td>使用<code>CALL</code>和存储过程</td>
</tr>
<tr>
<td><code>FILE</code></td>
<td>使用<code>SELECT INTO OUTFILE</code>和<code>LOAD DATA INFILE</code></td>
</tr>
<tr>
<td><code>GRANT OPTION</code></td>
<td>使用<code>CREATE INDEX</code>和<code>DROP INDEX</code></td>
</tr>
<tr>
<td><code>INDEX</code></td>
<td>使用<code>CREATE INDEX</code>和<code>DROP INDEX</code></td>
</tr>
<tr>
<td><code>INSERT</code></td>
<td>使用<code>INSERT</code></td>
</tr>
<tr>
<td><code>LOCK TABLES</code></td>
<td>使用<code>LOCK TABLES</code></td>
</tr>
<tr>
<td><code>PROCESS</code></td>
<td>使用<code>SHOW FULL PROCESSLIST</code></td>
</tr>
<tr>
<td><code>RELOAD</code></td>
<td>使用<code>FLUSH</code></td>
</tr>
<tr>
<td><code>REPLICATION CLIENT</code></td>
<td>服务器位置的访问</td>
</tr>
<tr>
<td><code>REPLICATION SLAVE</code></td>
<td>由复制从属使用</td>
</tr>
<tr>
<td><code>SELECT</code></td>
<td>使用<code>SELECT</code></td>
</tr>
<tr>
<td><code>SHOW DATABASES</code></td>
<td>使用<code>SHOW DATABASES</code></td>
</tr>
<tr>
<td><code>SHOW VIEW</code></td>
<td>使用<code>SHOW CREATE VIEW</code></td>
</tr>
<tr>
<td><code>SHUTDOWN</code></td>
<td>使用mysqladmin shutdown（用来关闭MySQL）</td>
</tr>
<tr>
<td><code>SUPER</code></td>
<td>使用<code>CHANGE MASTER</code>、<code>KILL</code>、<code>LOGS</code>、<code>PURGE</code>、<code>MASTER</code>和<code>SET GLOBAL</code>，还允许mysqladmin调试登录</td>
</tr>
<tr>
<td><code>UPDATE</code></td>
<td>使用<code>UPDATE</code></td>
</tr>
<tr>
<td><code>USAGE</code></td>
<td>无访问权限</td>
</tr>
</tbody></table>
<p>使用GRANT和REVOKE，在结合表中列出的权限，就能对用户具有完全的控制</p>
<p><strong>未来的授权</strong>：在使用GRANT和REVOKE时，用户账号必须存在，但对所涉及的对象没有这个要求</p>
<p>​	这允许管理员在创建数据库和表之前设计和实现安全措施</p>
<p>这样做的副作用是，当某个数据库或表被删除时(用DROP语句)，相关的访问权限仍然存在</p>
<p>而且，如果将来重新创建该数据库或表，这些权限仍然起作用</p>
<p><strong>简化多次授权</strong>：可通过列出各权限并用逗号分隔，将多条GRANT语句串在一起，如下所示：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT SELECT, INSERT ON crashcourse.* TO bforta;</span><br></pre></td></tr></table></figure></div>



<h3 id="更改口令"><a href="#更改口令" class="headerlink" title="更改口令"></a>更改口令</h3><p>为了更改用户口令，可使用<code>SET PASSWORD</code>语句</p>
<p>新口令必须如下加密：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET PASSWORD FOR bforta = Password(&#x27;n3w p@$$w0rd&#x27;);</span><br></pre></td></tr></table></figure></div>

<p><code>SET PASSWORD</code>更新用户口令</p>
<p>新口令必须传递到<code>Password()</code>函数进行加密</p>
<p><code>SET PASSWORD</code>还可以用来设置你自己的口令：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET PASSWORD = Password(&#x27;n3w p@$$w0rd&#x27;);</span><br></pre></td></tr></table></figure></div>

<p>在不指定用户名时，<code>SET PASSWORD</code>更新当前登录用户的口令</p>
<hr>
<h1 id="数据库维护"><a href="#数据库维护" class="headerlink" title="数据库维护"></a>数据库维护</h1><p>如何进行常见的数据库维护</p>
<h2 id="备份数据"><a href="#备份数据" class="headerlink" title="备份数据"></a>备份数据</h2><p>像所有数据一样，MySQL的数据也必须经常备份</p>
<p>由于MySQL数据是基于磁盘的文件，普通的备份系统和例程就能备份MySQL的数据</p>
<p>但是，由于这些文件总是处于打开和使用状态，普通的文件副本不一定总是有效的</p>
<p>下面列出这个问题的可能解决方案：</p>
<ul>
<li>使用命令行实用程序mysqldump转储所有数据库内容到某个外部文件<ul>
<li>在进行常规备份前这个使用程序应该正常运行，以便正确的备份转储文件</li>
</ul>
</li>
<li>可用命令行使用程序mysqlhotcopy从一个数据库复制所有数据(并非所有数据库引擎都支持这个实用程序)</li>
<li>可以使用MySQL的<code>BACKUP TABLE</code>或<code>SELECT INTO OUTFILE</code>转储所有数据到某个外部文件<ul>
<li>这两条语句都接受将要创建的系统文件名，此系统文件必须不存在，否则会出错</li>
<li>数据可以用<code>RESTORE TABLE</code>来复原</li>
</ul>
</li>
</ul>
<p><strong>首先刷新未写入数据</strong>：为了保证所有数据被写到磁盘(包括索引数据)，可能需要再进行备份前使用<code>FLUSH TABLES</code>语句</p>
<h2 id="进行数据库维护"><a href="#进行数据库维护" class="headerlink" title="进行数据库维护"></a>进行数据库维护</h2><p>MySQL提供了一系列的语句，可以(应该)用来保证数据库正确和正常运行</p>
<p>以下是应该知道的一些语句：</p>
<ul>
<li><code>ANALYZE TABLE</code>，用来检查表建是否正确</li>
</ul>
<p><code>ANALYZE TABLE</code>返回如下所示的状态信息：</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ANALYZE TABLE orders;</span><br></pre></td></tr></table></figure></div>

<p>输出：</p>
<table>
<thead>
<tr>
<th>Table</th>
<th>Op</th>
<th>Msg_type</th>
<th>Msg_taxt</th>
</tr>
</thead>
<tbody><tr>
<td>crashcourse.orders</td>
<td>analyze</td>
<td>status</td>
<td>OK</td>
</tr>
</tbody></table>
<ul>
<li><code>CHECK TABLE</code>用来针对许多问题对表进行检查<ul>
<li>在MyISAM表上海对索引进行检查</li>
<li><code>CHECK TABLE</code>支持一系列的用于MyISAM表的方式</li>
<li>CHANGED检查自最后一次检查以来改动过的表</li>
<li>EXTENDED执行最彻底的检查<ul>
<li>FAST只检查未正常关闭的表</li>
<li>MEDIUM检查所有被删除的链接并进行键检查</li>
<li>QUICK只进行快速扫描</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>如下所示，<code>CHECK TABLE</code>发现和修复问题：</p>
<p>输入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CHECK TABLE orders, orderitems;</span><br></pre></td></tr></table></figure></div>

<p>输出：</p>
<table>
<thead>
<tr>
<th>Table</th>
<th>Op</th>
<th>Msg_type</th>
<th>Msg_text</th>
</tr>
</thead>
<tbody><tr>
<td>crashocourse.orders</td>
<td>check</td>
<td>status</td>
<td>OK</td>
</tr>
<tr>
<td>crashcourse.orderitems</td>
<td>check</td>
<td>warning</td>
<td>Table is marked as crashed</td>
</tr>
<tr>
<td>crashcourse.orderitems</td>
<td>check</td>
<td>status</td>
<td>OK</td>
</tr>
</tbody></table>
<ul>
<li>如果MyTSAM表访问产生不正确和不一致的结果，可能需要用<code>REPAIR TABLE</code>来修复相应的表<ul>
<li>这条语句不应该经常使用，如果需要经常使用，可能会有更大的问题要解决</li>
</ul>
</li>
<li>如果从一个表中删除大量数据，应该使用<code>OPTIMIZE TABLE</code>来收回所用的空间，从而优化表的性能</li>
</ul>
<h2 id="诊断启动问题"><a href="#诊断启动问题" class="headerlink" title="诊断启动问题"></a>诊断启动问题</h2><p>服务器启动问题通常在对MySQL配置或服务器本身进行更改时出现</p>
<p>MySQL在这个问题发生时报告错误，但由于多数MySQL服务器是作为系统进程或服务自动启动的，这些消息可能看不到</p>
<p>在排除系统启动问题时，首先应该尽量用手动启动服务器</p>
<p>MySQL服务器自身通过在命令行上执行mysqld启动</p>
<p>下面是几个重要的mysqld命令行选项：</p>
<ul>
<li><code>--help</code>：显式帮助——一个选项列表</li>
<li><code>--safe-mode</code>：装载减去某些最佳配置的服务器</li>
<li><code>--verbose</code>：显式全文本消息(为获得更详细的帮助消息与<code>--help</code>联合使用)</li>
<li><code>--version</code>：显式版本信息然后退出</li>
</ul>
<p>几个另外的命令行选项(与日志文件有关)在下节列出</p>
<h2 id="查看日志文件"><a href="#查看日志文件" class="headerlink" title="查看日志文件"></a>查看日志文件</h2><p>MySQL维护管理员依赖的一系列日志文件</p>
<p>主要的日志文件有以下几中：</p>
<ul>
<li>错误日志<ul>
<li>它包含启动和关闭问题以及任意关键错误的细节</li>
<li>此日志通常名为<code>hostname.err</code>，位于data目录中</li>
<li>此日志名可用<code>--log-error</code>命令行选项更改</li>
</ul>
</li>
<li>查询日志<ul>
<li>它记录所有MySQL活动，在诊断问题时非常有用</li>
<li>此日志文件可能会很快的变得非常大，因此不应该长期使用它</li>
<li>此日志通常名为<code>hostname.log</code>，位于data目录中</li>
<li>此名字可以用<code>--log</code>命令行选项更改</li>
</ul>
</li>
<li>二进制日志<ul>
<li>它记录更新过数据(或啃更新过数据)的所有语句</li>
<li>此日志通常名为<code>hostname-bin</code>，位于data目录内</li>
<li>此名字可以用<code>--log-bin</code>命令行选项更改</li>
<li>注意，这个日志文件是MySQL5中添加的，以前的MySQL版本中使用的是更新日志</li>
</ul>
</li>
<li>缓慢查询日志<ul>
<li>此日志记录执行缓慢的任何查询</li>
<li>这个日志在确定数据库何处需要优化很有用</li>
<li>此日志通常名为<code>hostname-slow.log</code>，位于data目录中</li>
<li>此名字可以用<code>--log-slow-queries</code>命令行选项更改</li>
</ul>
</li>
</ul>
<p>在使用日志时，可用<code>FLUSH LOGS</code>语句来刷新和重新开始所有的日志文件</p>
<hr>
<h1 id="改善性能"><a href="#改善性能" class="headerlink" title="改善性能"></a>改善性能</h1><p>复习与MySQL性能有关的某些要点</p>
<h2 id="改善性能-1"><a href="#改善性能-1" class="headerlink" title="改善性能"></a>改善性能</h2><p>数据库管理员生命中的大部分时间在调整、试验以及改善DBMS性能上(</p>
<p>在诊断应用的滞缓现象和性能问题时，性能不良的数据库(以及数据库查询)通常是最常见的祸因</p>
<p>可见，下面的内容并不能完全决定MySQL的性能</p>
<p>只是想回顾一下前面的重点，提供进行性能优化探讨和分析的一个出发点</p>
<ul>
<li>首先，MySQL(与所有DBMS一样)具有特定的硬件协议<ul>
<li>在学习和研究MySQL时，使用任何旧的计算机作为服务器都可以</li>
<li>但对于生产的服务器来说，应该坚持遵循这些硬件建议</li>
</ul>
</li>
<li>一般来说，关键的生产DBMS应该运行在自己的专用服务器上</li>
<li>MySQL是用一系列的默认设置预先配置的，从这些设置开始通常是很好的<ul>
<li>但过段时间后可能需要调整内存分配、缓冲区大小等(为查看当前设置，可使用<code>SHOW VARIABLES;</code>和<code>SHOW STATUS;</code>)</li>
</ul>
</li>
<li>MySQL一个多用户多线程的DBMS<ul>
<li>就是说，它经常同时执行多个任务</li>
<li>如果这些任务重的某一个执行缓慢，则所有请求都会执行缓慢</li>
<li>如果遇到显著的性能不良没课使用<code>SHOW PROCESSLIST</code>显式所有活动进程(以及它们的线程ID和执行时间)</li>
<li>还可以用KILL命令终结某个特定的进程(使用这个命令需要作为管理员登录)</li>
</ul>
</li>
<li>总是有不止一种方法编写同一条SELECT语句<ul>
<li>应该试验联结、并、子查询等，找出最佳的方法</li>
</ul>
</li>
<li>使用<code>EXPLAIN</code>语句让MySQL解释它将如何执行一条SELECT语句</li>
<li>一般来说，存储过程执行的比一条一条的执行其中的各条MySQL语句块</li>
<li>应该总是使用正确的数据类型</li>
<li>绝不要检索比需求还要多的数据<ul>
<li>换言之，不要用<code>SELECT *</code>(除非真正需要每个列)</li>
</ul>
</li>
<li>有的操作(包括<code>INSERT</code>)支持一个可选的<code>DELAYED</code>关键字<ul>
<li>如果使用它，将把控制立即返回给调用程序，并且一旦有可能就实际执行该操作</li>
</ul>
</li>
<li>在导入数据时，应该关闭自动提交<ul>
<li>你可能还想删除索引(包括<code>FULLTEXT</code>索引)，然后在导入完成后再重建它们</li>
</ul>
</li>
<li>必须索引数据库表以改善数据检索的性能<ul>
<li>确定索引什么不是一件微不足道的任务，需要分析使用的SELECT语句以找到重复的<code>WHERE</code>和<code>ORDER BY</code>子句</li>
<li>如果一个简单的WHERE子句返回结果所花费的时间太长，则可以断定其中使用的列(或几个列)就是需要索引的对象</li>
</ul>
</li>
<li>你的SELECT语句中有一系列复杂的OR条件吗？<ul>
<li>通过使用多条SELECT语句和连接它们的UNION语句，你能看到极大的性能改进</li>
</ul>
</li>
<li>索引改善数据检索的性能，但损害数据插入、删除和更新的性能<ul>
<li>如果你有一些表，它们收集数据且不经常被搜索，则在有必要之前不要索引它们(索引可根据需要添加和删除)</li>
</ul>
</li>
<li>LIKE很慢<ul>
<li>一般来说，最好是使用<code>FULLTEXT</code>而不是LIKE</li>
</ul>
</li>
<li>数据库是不断变化的实体<ul>
<li>一组优化良好的表一会儿后可能就面目全非了</li>
<li>由于表的使用和内容的更改，理想的优化和配置也会改变</li>
</ul>
</li>
<li>最重要的规则就是，每条规则在某些提哦啊见下都会被打破</li>
</ul>
<p><strong>浏览文档</strong>：位于<a class="link"   target="_blank" rel="noopener" href="http://dev.mysql.com/doc/%E7%9A%84MySQL%E6%96%87%E6%A1%A3%E6%9C%89%E8%AE%B8%E5%A4%9A%E6%8F%90%E7%A4%BA%E5%92%8C%E6%8A%80%E5%B7%A7%EF%BC%88%E7%94%9A%E8%87%B3%E6%9C%89%E7%94%A8%E6%88%B7%E6%8F%90%E4%BE%9B%E7%9A%84%E8%AF%84%E8%AE%BA%E5%92%8C%E5%8F%8D%E9%A6%88%EF%BC%89" >http://dev.mysql.com/doc/的MySQL文档有许多提示和技巧（甚至有用户提供的评论和反馈） <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>​	一定要查看这些非常有价值的资料</p>
<hr>
<p>(完结撒花)</p>

        </div>

        
            <div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
                <div class="article-copyright-info-container">
    <ul>
        <li><strong>标题:</strong> MySQL必知必会笔记</li>
        <li><strong>作者:</strong> GuangYing</li>
        <li><strong>创建于
                :</strong> 2024-10-18 15:52:53</li>
        
            <li>
                <strong>更新于
                    :</strong> 2024-11-05 21:30:08
            </li>
        
        <li>
            <strong>链接:</strong> http://quebo.cn/2024/10/18/MySQL必知必会/
        </li>
        <li>
            <strong>
                版权声明:
            </strong>
            

            
                本文章采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a> 进行许可。
            
        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
                
                    <li class="tag-item mx-0.5">
                        <a href="/tags/%E7%AC%94%E8%AE%B0/">#笔记</a>&nbsp;
                    </li>
                
                    <li class="tag-item mx-0.5">
                        <a href="/tags/MySQL/">#MySQL</a>&nbsp;
                    </li>
                
                    <li class="tag-item mx-0.5">
                        <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">#数据库</a>&nbsp;
                    </li>
                
            </ul>
        

        

        
            <div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
                
                    <div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
                        <a class="prev"
                        rel="prev"
                        href="/2024/10/21/8086%E6%B1%87%E7%BC%96/"
                        >
                            <span class="left arrow-icon flex justify-center items-center">
                                <i class="fa-solid fa-chevron-left"></i>
                            </span>
                            <span class="title flex justify-center items-center">
                                <span class="post-nav-title-item">8086汇编</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
                        <a class="next"
                        rel="next"
                        href="/2024/10/17/hello-world/"
                        >
                            <span class="title flex justify-center items-center">
                                <span class="post-nav-title-item">欢迎来到芝士博客</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex justify-center items-center">
                                <i class="fa-solid fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        


        
    </div>

    
        <div class="toc-content-container">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">目录</div>
        <div class="page-title">MySQL必知必会笔记</div>
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8MySQL"><span class="nav-text">使用MySQL</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-text">选择数据库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8"><span class="nav-text">了解数据库和表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE"><span class="nav-text">检索数据</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#SELECT%E8%AF%AD%E5%8F%A5"><span class="nav-text">SELECT语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A3%80%E7%B4%A2%E5%8D%95%E4%B8%AA%E5%88%97"><span class="nav-text">检索单个列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A3%80%E7%B4%A2%E5%A4%9A%E4%B8%AA%E5%88%97"><span class="nav-text">检索多个列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A3%80%E7%B4%A2%E6%89%80%E6%9C%89%E5%88%97"><span class="nav-text">检索所有列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A3%80%E7%B4%A2%E4%B8%8D%E5%90%8C%E7%9A%84%E8%A1%8C"><span class="nav-text">检索不同的行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%90%E5%88%B6%E7%BB%93%E6%9E%9C"><span class="nav-text">限制结果</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%8C%E5%85%A8%E9%99%90%E5%AE%9A%E7%9A%84%E8%A1%A8%E5%90%8D"><span class="nav-text">使用完全限定的表名</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE"><span class="nav-text">排序检索数据</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E6%95%B0%E6%8D%AE"><span class="nav-text">排序数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%89%E5%A4%9A%E4%B8%AA%E5%88%97%E6%8E%92%E5%BA%8F"><span class="nav-text">按多个列排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E6%8E%92%E5%BA%8F%E6%96%B9%E5%90%91"><span class="nav-text">指定排序方向</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4%E6%95%B0%E6%8D%AE"><span class="nav-text">过滤数据</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8WHERE%E5%AD%90%E5%8F%A5"><span class="nav-text">使用WHERE子句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WHERE%E5%AD%90%E5%8F%A5%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">WHERE子句操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E5%8D%95%E4%B8%AA%E5%80%BC"><span class="nav-text">检查单个值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%8C%B9%E9%85%8D%E6%A3%80%E6%9F%A5"><span class="nav-text">不匹配检查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8C%83%E5%9B%B4%E5%80%BC%E6%A3%80%E6%9F%A5"><span class="nav-text">范围值检查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E5%80%BC%E6%A3%80%E6%9F%A5"><span class="nav-text">空值检查</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4"><span class="nav-text">数据过滤</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E5%90%88WHERE%E5%AD%90%E5%8F%A5"><span class="nav-text">组合WHERE子句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AND%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">AND操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OR%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">OR操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%AC%A1%E5%BA%8F"><span class="nav-text">计算次序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IN%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">IN操作符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NOT%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">NOT操作符</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4"><span class="nav-text">用通配符进行过滤</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#LIKE%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">LIKE操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%99%BE%E5%88%86%E5%8F%B7-%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="nav-text">百分号(%)通配符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8B%E5%88%92%E7%BA%BF-%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="nav-text">下划线(_)通配符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E6%8A%80%E5%B7%A7"><span class="nav-text">使用通配符的技巧</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E6%90%9C%E7%B4%A2"><span class="nav-text">用正则表达式进行搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BB%8B%E7%BB%8D"><span class="nav-text">正则表达式介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8MySQL%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">使用MySQL正则表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%AD%97%E7%AC%A6%E5%8C%B9%E9%85%8D"><span class="nav-text">基本字符匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E8%A1%8COR%E5%8C%B9%E9%85%8D"><span class="nav-text">进行OR匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%B9%E9%85%8D%E5%87%A0%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B9%8B%E4%B8%80"><span class="nav-text">匹配几个字符之一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%B9%E9%85%8D%E8%8C%83%E5%9B%B4"><span class="nav-text">匹配范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%B9%E9%85%8D%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6"><span class="nav-text">匹配特殊字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%B9%E9%85%8D%E5%AD%97%E7%AC%A6%E7%B1%BB"><span class="nav-text">匹配字符类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%B9%E9%85%8D%E5%A4%9A%E4%B8%AA%E5%AE%9E%E4%BE%8B"><span class="nav-text">匹配多个实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%BD%8D%E7%AC%A6"><span class="nav-text">定位符</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5"><span class="nav-text">创建计算字段</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5"><span class="nav-text">计算字段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%BC%E6%8E%A5%E5%AD%97%E6%AE%B5"><span class="nav-text">拼接字段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E7%AE%97%E6%95%B0%E8%AE%A1%E7%AE%97"><span class="nav-text">执行算数计算</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-text">使用数据处理函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-text">函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0"><span class="nav-text">使用函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-text">文本处理函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-text">日期和时间处理函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-text">数组处理函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B1%87%E6%80%BB%E6%95%B0%E6%8D%AE"><span class="nav-text">汇总数据</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0"><span class="nav-text">聚集函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AVG-%E5%87%BD%E6%95%B0"><span class="nav-text">AVG()函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#COUNT-%E5%87%BD%E6%95%B0"><span class="nav-text">COUNT()函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MAX-%E5%87%BD%E6%95%B0"><span class="nav-text">MAX()函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MIN-%E5%87%BD%E6%95%B0"><span class="nav-text">MIN()函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SUM-%E5%87%BD%E6%95%B0"><span class="nav-text">SUM()函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%9A%E9%9B%86%E4%B8%8D%E5%90%8C%E5%80%BC"><span class="nav-text">聚集不同值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0"><span class="nav-text">组合聚集函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E7%BB%84%E6%95%B0%E6%8D%AE"><span class="nav-text">分组数据</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%88%86%E7%BB%84"><span class="nav-text">数据分组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%88%86%E7%BB%84"><span class="nav-text">创建分组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4%E5%88%86%E7%BB%84"><span class="nav-text">过滤分组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E7%BB%84%E5%92%8C%E6%8E%92%E5%BA%8F"><span class="nav-text">分组和排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SELECT%E5%AD%90%E5%8F%A5%E9%A1%BA%E5%BA%8F"><span class="nav-text">SELECT子句顺序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="nav-text">使用子查询</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="nav-text">子查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4"><span class="nav-text">利用子查询进行过滤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%9C%E4%B8%BA%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5%E4%BD%BF%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="nav-text">作为计算字段使用子查询</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%81%94%E7%BB%93%E8%A1%A8"><span class="nav-text">联结表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%94%E7%BB%93"><span class="nav-text">联结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E8%A1%A8"><span class="nav-text">关系表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E8%81%94%E7%BB%93"><span class="nav-text">为什么要使用联结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%81%94%E7%BB%93"><span class="nav-text">创建联结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#WHERE%E5%AD%90%E5%8F%A5%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="nav-text">WHERE子句的重要性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E8%81%94%E7%BB%93"><span class="nav-text">内部联结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%94%E7%BB%93%E5%A4%9A%E4%B8%AA%E8%A1%A8"><span class="nav-text">联结多个表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E9%AB%98%E7%BA%A7%E8%81%94%E7%BB%93"><span class="nav-text">创建高级联结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%A1%A8%E5%88%AB%E5%90%8D"><span class="nav-text">使用表别名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%81%94%E7%BB%93"><span class="nav-text">使用不同类型的联结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E8%81%94%E7%BB%93"><span class="nav-text">自联结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E7%84%B6%E8%81%94%E7%BB%93"><span class="nav-text">自然联结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E8%81%94%E7%BB%93"><span class="nav-text">外部联结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%B8%A6%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0%E7%9A%84%E8%81%94%E7%BB%93"><span class="nav-text">使用带聚集函数的联结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%81%94%E7%BB%93%E5%92%8C%E8%81%94%E7%BB%93%E6%9D%A1%E4%BB%B6"><span class="nav-text">使用联结和联结条件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2"><span class="nav-text">组合查询</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2-1"><span class="nav-text">组合查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2"><span class="nav-text">创建组合查询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8UNION"><span class="nav-text">使用UNION</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UNION%E8%A7%84%E5%88%99"><span class="nav-text">UNION规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%85%E5%90%AB%E6%88%96%E5%8F%96%E6%B6%88%E9%87%8D%E5%A4%8D%E7%9A%84%E8%A1%8C"><span class="nav-text">包含或取消重复的行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E6%8E%92%E5%BA%8F"><span class="nav-text">对组合查询结果排序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2"><span class="nav-text">全文本搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%90%86%E8%A7%A3%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2"><span class="nav-text">理解全文本搜索</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2"><span class="nav-text">使用全文本搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E7%94%A8%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2%E6%94%AF%E6%8C%81"><span class="nav-text">启用全文本搜索支持</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E8%A1%8C%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2"><span class="nav-text">进行全文本搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%9F%A5%E8%AF%A2%E6%89%A9%E5%B1%95"><span class="nav-text">使用查询扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%83%E5%B0%94%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2"><span class="nav-text">布尔文本搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E"><span class="nav-text">全文本搜索的使用说明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="nav-text">插入数据</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%8F%92%E5%85%A5"><span class="nav-text">数据插入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E5%AE%8C%E6%95%B4%E7%9A%84%E8%A1%8C"><span class="nav-text">插入完整的行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E5%A4%9A%E4%B8%AA%E8%A1%8C"><span class="nav-text">插入多个行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%A3%80%E7%B4%A2%E5%87%BA%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-text">插入检索出的数据</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E5%92%8C%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"><span class="nav-text">更新和删除数据</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE"><span class="nav-text">更新数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"><span class="nav-text">删除数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E5%92%8C%E5%88%A0%E9%99%A4%E7%9A%84%E6%8C%87%E5%AF%BC%E5%8E%9F%E5%88%99"><span class="nav-text">更新和删除的指导原则</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E6%93%8D%E7%BA%B5%E8%A1%A8"><span class="nav-text">创建和操纵表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%A1%A8"><span class="nav-text">创建表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E5%88%9B%E5%BB%BA%E5%9F%BA%E7%A1%80"><span class="nav-text">表创建基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8NULL%E5%80%BC"><span class="nav-text">使用NULL值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E9%94%AE%E5%86%8D%E4%BB%8B%E7%BB%8D"><span class="nav-text">主键再介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8AUTO-INCREMENT"><span class="nav-text">使用AUTO_INCREMENT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="nav-text">指定默认值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E6%93%8E%E7%B1%BB%E5%9E%8B"><span class="nav-text">引擎类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E8%A1%A8"><span class="nav-text">更新表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E8%A1%A8"><span class="nav-text">删除表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E5%91%BD%E5%90%8D%E8%A1%A8"><span class="nav-text">重命名表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE"><span class="nav-text">使用视图</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%86%E5%9B%BE"><span class="nav-text">视图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE"><span class="nav-text">为什么使用视图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%86%E5%9B%BE%E7%9A%84%E8%A7%84%E5%88%99%E5%92%8C%E9%99%90%E5%88%B6"><span class="nav-text">视图的规则和限制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE-1"><span class="nav-text">使用视图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E8%A7%86%E5%9B%BE%E7%AE%80%E5%8C%96%E5%A4%8D%E6%9D%82%E7%9A%84%E8%81%94%E7%BB%93"><span class="nav-text">利用视图简化复杂的联结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E8%A7%86%E5%9B%BE%E9%87%8D%E6%96%B0%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%A3%80%E7%B4%A2%E5%87%BA%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-text">用视图重新格式化检索出的数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E8%A7%86%E5%9B%BE%E8%BF%87%E6%BB%A4%E4%B8%8D%E6%83%B3%E8%A6%81%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-text">用视图过滤不想要的数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE%E4%B8%8E%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5"><span class="nav-text">使用视图与计算字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E8%A7%86%E5%9B%BE"><span class="nav-text">更新视图</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="nav-text">使用存储过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="nav-text">存储过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="nav-text">为什么要使用存储过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B-1"><span class="nav-text">使用存储过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="nav-text">创建存储过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="nav-text">删除存储过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%82%E6%95%B0"><span class="nav-text">使用参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E6%99%BA%E8%83%BD%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="nav-text">建立智能存储过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="nav-text">检查存储过程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%B8%B8%E6%A0%87"><span class="nav-text">使用游标</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B8%B8%E6%A0%87"><span class="nav-text">游标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%B8%B8%E6%A0%87-1"><span class="nav-text">使用游标</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%B8%B8%E6%A0%87"><span class="nav-text">创建游标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%93%E5%BC%80%E5%92%8C%E5%85%B3%E9%97%AD%E6%B8%B8%E6%A0%87"><span class="nav-text">打开和关闭游标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%B8%B8%E6%A0%87%E6%95%B0%E6%8D%AE"><span class="nav-text">使用游标数据</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="nav-text">使用触发器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="nav-text">触发器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="nav-text">创建触发器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="nav-text">删除触发器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%A7%A6%E5%8F%91%E5%99%A8-1"><span class="nav-text">使用触发器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#INSERT%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="nav-text">INSERT触发器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DELETE%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="nav-text">DELETE触发器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UPDATE%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="nav-text">UPDATE触发器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E8%A7%A6%E5%8F%91%E5%99%A8%E7%9A%84%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BB%8B%E7%BB%8D"><span class="nav-text">关于触发器的进一步介绍</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%A1%E7%90%86%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86"><span class="nav-text">管理事务处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86"><span class="nav-text">事务处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86"><span class="nav-text">控制事务处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8ROLLBACK"><span class="nav-text">使用ROLLBACK</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8COMMIT"><span class="nav-text">使用COMMIT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%BF%9D%E7%95%99%E7%82%B9"><span class="nav-text">使用保留点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%94%B9%E9%BB%98%E8%AE%A4%E7%9A%84%E6%8F%90%E4%BA%A4%E8%A1%8C%E4%B8%BA"><span class="nav-text">更改默认的提交行为</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%A8%E7%90%83%E5%8C%96%E5%92%8C%E6%9C%AC%E5%9C%B0%E5%8C%96"><span class="nav-text">全球化和本地化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%A0%A1%E5%AF%B9%E9%A1%BA%E5%BA%8F"><span class="nav-text">字符集和校对顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%A0%A1%E5%AF%B9%E9%A1%BA%E5%BA%8F"><span class="nav-text">使用字符集和校对顺序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86"><span class="nav-text">安全管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="nav-text">访问控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%A1%E7%90%86%E7%94%A8%E6%88%B7"><span class="nav-text">管理用户</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E8%B4%A6%E5%8F%B7"><span class="nav-text">创建用户账号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7%E8%B4%A6%E5%8F%B7"><span class="nav-text">删除用户账号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="nav-text">设置访问权限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%94%B9%E5%8F%A3%E4%BB%A4"><span class="nav-text">更改口令</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%B4%E6%8A%A4"><span class="nav-text">数据库维护</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%87%E4%BB%BD%E6%95%B0%E6%8D%AE"><span class="nav-text">备份数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%B4%E6%8A%A4"><span class="nav-text">进行数据库维护</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%8A%E6%96%AD%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98"><span class="nav-text">诊断启动问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6"><span class="nav-text">查看日志文件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%94%B9%E5%96%84%E6%80%A7%E8%83%BD"><span class="nav-text">改善性能</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%94%B9%E5%96%84%E6%80%A7%E8%83%BD-1"><span class="nav-text">改善性能</span></a></li></ol></li></ol>

    </div>
</div>
        </div>
    
</div>



                

            </div>

            

        </div>

        <div class="main-content-footer">
            <footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
            <div class="customize-info my-1">不再看一会儿吗O.o</div>
        
        <div class="text-center">
            &copy;
            
              <span>2024</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">GuangYing</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        共撰写了 7 篇文章
                    </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">访问人数</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">总访问量</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">由 <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a> 驱动</span>
            <span class="text-sm lg:block">主题&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.7.1</a></span>
        </div>
        
            <div class="icp-info my-1"><a target="_blank" rel="nofollow" href="
                
                    https://icp.gov.moe/?keyword=20250606
                
                ">萌ICP备20250606号</a></div>
        
        
            <div>
                博客已运行 <span class="odometer" id="runtime_days" ></span> 天 <span class="odometer" id="runtime_hours"></span> 小时 <span class="odometer" id="runtime_minutes"></span> 分钟 <span class="odometer" id="runtime_seconds"></span> 秒
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="article-tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-side-tools-container">
        <div class="side-tools-container">
    <ul class="hidden-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="visible-tools-list">
        <li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
            <li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    

</main>


    
<script src="/js/libs/Swup.min.js"></script>

<script src="/js/libs/SwupSlideTheme.min.js"></script>

<script src="/js/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>







<script src="/js/tools/imageViewer.js" type="module"></script>

<script src="/js/utils.js" type="module"></script>

<script src="/js/main.js" type="module"></script>

<script src="/js/layouts/navbarShrink.js" type="module"></script>

<script src="/js/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/layouts/categoryList.js" type="module"></script>





    
<script src="/js/tools/codeBlock.js" type="module"></script>




    
<script src="/js/layouts/lazyload.js" type="module"></script>




    
<script src="/js/tools/runtime.js"></script>

    
<script src="/js/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/libs/Typed.min.js"></script>

  
<script src="/js/plugins/typed.js" type="module"></script>








    
<script src="/js/libs/anime.min.js"></script>



<div class="post-scripts" data-swup-reload-script>
    
        
<script src="/js/tools/tocToggle.js" type="module"></script>

<script src="/js/layouts/toc.js" type="module"></script>

<script src="/js/plugins/tabs.js" type="module"></script>

    
</div>


</body>
</html>
